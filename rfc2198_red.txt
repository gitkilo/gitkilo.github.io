RTP Payload for Redundant Audio Data

翻译于[rfc2198](https://www.ietf.org/rfc/rfc2198.txt)

第2节介绍了导致定义此有效载荷格式的要求和动机，并且不构成有效载荷格式定义的一部分。 第3节开始定义了冗余音频数据的RTP有效负载格式。

# 2.需求/动机

RTP下对冗余编码方案的要求如下：

- 分组必须携带主要编码和一个或多个冗余编码。
- 由于多种编码可用于冗余信息，因此冗余编码的每个块必须具有编码类型标识符。
- 由于期望使用可变大小的编码，因此分组中的每个编码块必须具有长度指示符。
- RTP标头提供了一个时间戳字段，该字段与创建编码数据的时间相对应。 当使用冗余编码时，该时间戳字段可以指代主要编码数据的创建时间。冗余数据块将与原始数据对应不同的时间间隔，因此冗余编码的每个块将需要其自己的时间戳。为了减少携带时间戳所需的字节数，可以将其编码为冗余编码的时间戳与主数据库的时间戳之差。

可以通过两种基本方式将冗余音频添加到标准RTP规范中：标头扩展可以保留冗余，或者可以定义一种或多种其他有效负载类型。

将数据包的所有冗余信息包括在头扩展中将使未实现冗余的应用程序可以轻松地丢弃它，而仅处理主编码数据。 但是，此方案有许多缺点：

- 扩展标头（4）所需的字节数以及扩展末尾向上舍入到四个字节边界（最多3个字节）所需的填充有很大的开销。 对于许多应用程序来说，这种开销是不可接受的。
- 标头扩展名的使用将应用程序限制为单个冗余编码，除非在扩展名中引入了进一步的结构。 这将导致更多的开销。

由于这些原因，不考虑使用RTP标头扩展来保存冗余音频编码。

音频和视频会议的RTP配置文件[3]列出了一组有效负载类型，并提供了可以通过会议控制协议定义的32种编码的动态范围。 这导致为冗余音频应用分配其他RTP有效负载类型的两种可能方案：

1. 可以使用RTP动态有效载荷类型范围为primary/冗余有效载荷类型的每种组合定义动态编码方案。
2. 可以定义单个固定的有效载荷类型来表示具有冗余的数据包。 然后，可以将其分配给静态RTP有效负载类型，或者可以将其动态分配给它。

可以定义一组有效载荷类型，这些类型表示针对所提供的32种动态有效载荷类型中的每种的主要和辅助编码的特定组合。对于具有单个冗余块的分组，由于可能的组合的数量不是太大，所以这将是一种限制性的但可行的解决方案。 但是，对多个冗余块的需求大大增加了编码组合的数量，并使该解决方案不可行。

上述解决方案的修改版本可以是在会议开始之前决定一组32个编码组合，这些组合将在会议期间使用。会议中的所有工具都可以使用此编码组合工作集进行初始化。 可以通过使用外部带外机制来进行工作集的通信。设置非常复杂，因为在启动具有相同参数的工具时要格外小心。 由于仅使用一个字节来标识编码组合，因此该方案效率更高。

可以感觉到，在将有效载荷类型的映射分布到冗余数据的组合上时固有的复杂性使该机制无法使用。

更为灵活的解决方案是具有单个有效负载类型，该类型表示具有冗余的数据包。 然后，该数据包成为一个容器，将多个有效载荷封装到单个RTP数据包中。 这样的方案是灵活的，因为任何数量的冗余都可以封装在单个数据包内。但是，开销很小，因为每个封装的有效负载之前都必须有一个标头，指示包含的数据类型。 这是首选的解决方案，因为它既灵活，可扩展，又具有相对较低的开销。 本文档的其余部分介绍了此解决方案。

# 3.有效载荷格式规范

对于这种新的数据包格式，RTP有效负载类型的分配超出了本文档的范围，在此不再赘述。 期望针对特定应用类别的RTP配置文件将为此编码分配有效负载类型，或者如果未完成，则应选择动态范围内的有效负载类型。

包含冗余数据的RTP分组应具有标准的RTP报头，其有效载荷类型指示冗余。 RTP标头的其他字段与冗余数据的主数据块有关。

RTP头之后是下图中定义的许多其他头，它们指定了数据包所携带的每种编码的内容。 这些附加头之后是许多数据块，其中包含这些编码的标准RTP有效负载数据。注意，所有报头都对准32位边界，但是有效载荷数据通常将不对准。 如果数据包中包含多个冗余编码，则它们应对应于不同的时间间隔：没有理由在数据包中的单个时间间隔内包含多个数据副本。

```c
    0                   1                    2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |F|   block PT  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

标头中的位指定如下：

F：1 bit，标头中的第一位指示是否跟随另一个标头块。如果为1后面还有一个头块，如果为0，这是最后一个头块。

block PT：7 bits，该块的RTP有效负载类型。

timestamp offset：14 bits，相对于RTP标头中给出的时间戳，此块时间戳的无符号偏移。使用无符号偏移量意味着必须在主数据之后发送冗余数据，因此，这是从当前时间戳中减去以确定该块为其冗余的数据时间戳的时间。

block length：10 bits，相应数据块的长度（字节），不包括头。

注意，使用无符号时间戳偏移会稍微限制冗余数据的使用：不可能在主编码之前发送冗余。这可能会影响在编码过程中尽早产生适用于冗余的低带宽编码的方案，因此有可能提早发送。但是，符号位的增加将不可接受地减小时间戳偏移的范围，并且将字段的大小增加到14位以上会限制块长度字段。与限制其他字段的大小相比，限制在主要对象之后传输的冗余似乎引起的问题更少。

冗余块的时间戳偏移以与主要编码的时间戳相同的单位进行测量（即：音频采样，其时钟速率与主要编码相同）。 这意味着必须以与主编码相同的速率对冗余编码进行采样。

还要注意，块长度和时间戳偏移分别是10位和14位； 而不是更明显的8位和16位。虽然这种编码使解析头信息变得有些复杂，并增加了一些额外的处理开销，但更明显的选择涉及许多问题：8位块长度字段对于大多数（但不是全部）可能的编码就足够了： 示例80毫秒PCM和DVI音频数据包包含超过256个字节，并且无法使用单个字节长度字段进行编码。可以在块长度字段上强加其他结构（例如，高位集可能意味着低7位用字而不是字节来编码长度），但是这种方案很复杂。 10位块长度字段的使用保留了简单性，并提供了更大的范围，但代价是减少了时间戳值的范围。

主编码块头位于数据包的最后。 因此可以从该块的报头中省略时间戳和块长度字段，因为它们可以从RTP报头和整个包长度中确定。 主（最终）块的头仅包括一个零F位，而块有效载荷类型信息总共为8位。 如下图所示：

```c
                      0 1 2 3 4 5 6 7
                     +-+-+-+-+-+-+-+-+
                     |0|   Block PT  |
                     +-+-+-+-+-+-+-+-+
```

最终的标头后面紧跟着数据块，它们以与标头相同的顺序存储。 数据块之间没有填充或其他定界符，并且它们通常不是32位对齐的。 同样，做出此选择是为了减少带宽开销，但要花费额外的解码时间。

使用的编码选择应反映这些编码的带宽要求。预计冗余编码使用的带宽将比主编码少得多：例外是主带宽非常低且处理要求高的情况，在这种情况下，主编码的副本可以用作冗余 。冗余编码不得超过主编码带宽。**很少需要使用多个级别的冗余。 但是，在需要的情况下，每个冗余级别所需的带宽预计将大大小于先前级别的带宽。**

# 4.局限性

对于冗余数据块，不会保留RTP标记位。 因此，如果主要对象（包含此标记）丢失，则标记也会丢失。相信这不会引起不适当的问题：即使标记位是与冗余信息一起发送的，它仍然有丢失的可能性，因此仍然必须牢记这一点来编写应用程序。

另外，不会为冗余数据保留CSRC信息。 冗余音频数据包的RTP标头中的CSRC数据仅与主数据有关。由于期望音频流中的CSRC数据相对不频繁地发生更改，因此建议需要此信息的应用程序假定RTP头中的CSRC数据可以应用于重构的冗余数据。

# 5.与SDP的关系

使用冗余有效负载时，可能需要将其绑定到RTP动态有效负载类型。 这可以通过任何带外机制来实现，但是一种常见的方式是使用会话描述协议（SDP）[6]来传达此绑定。SDP具有一种机制，可以使用“ rtpmap”属性将动态有效负载类型绑定到特定的编解码器，采样率和通道数。 其用法的示例（使用RTP音频/视频配置文件[3]）是：

```c
       m=audio 12345 RTP/AVP 121 0 5
       a=rtpmap:121 red/8000/1
```

这指定使用RTP的音频流正在使用有效负载类型121（动态有效负载类型），0（PCM u-law）和5（DVI）。 “ rtpmap”属性用于将有效载荷类型121绑定到编解码器“red”，指示该编解码器实际上是冗余帧，8KHz和单声道。 当与SDP一起使用时，术语“red”用于表示本文档中讨论的冗余格式。

在这种情况下，将指定PCM和DVI的其他格式。 因此，接收者必须准备使用这些格式。 这样的规范意味着发送方默认会发送冗余，但也可能发送PCM或DVI。但是，对于冗余有效负载，我们另外将其表示为在冗余编码中将不使用除PCM或DVI以外的其他编解码器。请注意，在“ m =”字段中定义的其他有效载荷格式本身可能是动态有效载荷类型，如果是这样，则可能需要大量其他“ a =”属性来描述这些动态有效载荷类型。

要接收冗余流，仅需这些。 但是，要发送冗余流，发送方需要知道为主要和次要（以及三次等）编码推荐使用哪些编解码器。此信息特定于冗余格式，并使用附加属性“ fmtp”指定，该属性传达特定于格式的信息。 会话目录不会解析fmtp属性中指定的值，而只会将其原样交给媒体工具。为了实现冗余，我们将格式参数定义为RTP有效负载类型的斜杠“ /”分隔列表。

因此，一个完整的示例是：

```c
       m=audio 12345 RTP/AVP 121 0 5
       a=rtpmap:121 red/8000/1
       a=fmtp:121 0/5
```

这指定发送方的默认格式是冗余，其中PCM为主要编码，DVI为辅助编码。 除非在媒体（“ m =”）行上也将其指定为有效编码，否则无法在fmtp属性中指定编码。

# 6.安全注意事项

包含冗余信息的RTP数据包必须遵守RTP规范[2]和任何适当的RTP配置文件（例如[3]）中讨论的安全性考虑。 这意味着媒体流的机密性是通过加密来实现的。冗余数据流的加密可以通过两种方式进行：

1. 整个流将得到保护，并且所有参与者都应具有用于解码整个流的密钥。 在这种情况下，不需要做特别的事情，并且以通常的方式执行加密。
2. 流的一部分将使用与其余部分不同的密钥进行加密。 在这种情况下，该部分的最后一个数据包的冗余副本无法发送，因为没有随后的数据包使用正确的密钥加密了。 启用/禁用加密时可能会发生类似的限制。

两者之间的选择仅与编码器有关。解码器可以解密任何一种形式而无需修改。

向音频流添加低带宽冗余是一种有效的方法，可以保护该流免受数据包丢失的影响，但应用程序设计人员应注意，添加大量冗余将增加网络拥塞，从而增加数据包丢失， 导致使用冗余旨在解决的问题恶化。 最坏的情况是，这可能导致过度的网络拥塞，并可能构成拒绝服务攻击。

# 7.示例数据包

如RTP音频/视频配置文件[3]中所定义，一个RTP音频数据包包含一个DVI4（8KHz）主信号和一个使用8KHz LPC编码的单个冗余块（均为20ms包）：

```c
    0                   1                    2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X| CC=0  |M|      PT     |   sequence number of primary  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              timestamp  of primary encoding                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1| block PT=7  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0| block PT=5  |                                               |
   +-+-+-+-+-+-+-+-+                                               +
   |                                                               |
   +                LPC encoded redundant data (PT=7)              +
   |                (14 bytes)                                     |
   +                                               +---------------+
   |                                               |               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                                               +
   |                DVI4 encoded primary data (PT=5)               |
   +                (84 bytes, not to scale)                       +
   /                                                               /
   +                                                               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                               +---------------+
   |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

