# webrtc之ULPFEC

[RFC5109](https://www.ietf.org/rfc/rfc5109.txt)

# 1. 前言

  WebRTC主要采取两种手段对抗网络丢包：丢包重传（NACK）和前向纠错（FEC）。本文主要在于FEC的学习。FEC是一种前向纠错技术，发送端将负载数据加上一定的冗余纠错码一起发送，接收端根据接收到的纠错码对数据进行差错检测，如果发现差错，则利用纠错码进行纠错。而ULPFEC（Uneven Level Protection FEC，非均等保护前向纠错）则是WebRTC实现的FEC方案之一。

# 2. ULPFEC理论学习

  ULPFEC由[RFC5109](https://www.ietf.org/rfc/rfc5109.txt)定义，在WebRTC中以RED格式进一步封装在RTP中传输。该标准使用XOR操作基于多个多媒体数据包生成FEC数据包，然后在接收端根据FEC数据包和已接收数据包恢复丢失的数据包。ULPFEC能够针对不同的数据包提供不同的保护级别，从而对重要的数据包提供更多的保护。

## 2.1 ULPFEC基本概念

  ULPFEC数据包中包含发送端需要告知接收端的一些重要信息，包括本FEC数据包所保护的媒体数据、保护级别和每个级别的保护长度。特别的，FEC数据包针对每个保护级别k设置一个偏移量掩码m(k)，如果m(k)的第i位被置为1，则序列号为N+i的媒体数据包在本FEC包的第k级别被保护。其中N为基准序列号，在本FEC包中设置。第k级别保护的媒体数据大小由L(k)指示，该值也在FEC包中设置。以上保护长度、偏移量掩码、负载类型和基准序列号能够完全确定生成FEC数据包中的奇偶校验码。

  一般来说，FEC是带宽和保护力度的权衡，针对同样的媒体数据，更多的FEC数据包意味着更有力的抗丢包保护，但同时也会消耗更多的带宽。通常情况下，对于媒体数据包，不同部分的重要程度不一样，因此，我们可以针对数据包的不同部分实施不同程度保护（即非均等保护前向纠错），以充分利用带宽资源。更多带宽花费在更重要的数据部分，相反，较少带宽花费在不那么重要的数据部分。媒体数据包根据重要程度划分为若干部分，每个部分就是我们所说的保护级别，每个部分的长度即为保护长度，每个FEC包可携带多个保护级别的奇偶校验码。根据数据包不同部分重要程度进行保护的算法，就是所谓的ULPFEC非均等保护前向纠错。

```c

         Packet A          #####################
                                  :        :
         Packet B          ############### :
                                  :        :
         ULP FEC Packet #1 @@@@@@@@        :
                                  :        :
         Packet C          ###########     :
                                  :        :
         Packet D          ###################################
                                  :        :
         ULP FEC Packet #2 @@@@@@@@@@@@@@@@@
                           :      :        :
                           :<-L0->:<--L1-->:

        Payload packet #  |  ULP FEC packet that protects at level
                           |          L0             L1
      ---------------------+---------------------------------------
                A          |          #1             #2
                B          |          #1             #2
                C          |          #2             #2
                D          |          #2             #2
```

​                                                                          图1：Unequal Level Protection

ULP FEC不仅为数据包的开头提供了更多保护（虽然这个更为重要），它还尽可能避免出现效率较低的情况，即数据包的较早部分不可恢复，而较晚部分可以恢复（并且经常必须丢弃）

  图1很好说明了ULP的概念：FEC包1在L0级别保护数据包A和B，FEC包2在L0级别保护数据包C和D，同时在L1级别保护数据包A、B、C和D。注意FEC包1和FEC包2的保护数据包集合不一样大，同时保护长度也不一样长。

## 2.2 ULPFEC报文格式

  ULPFEC报文由一个头部和多个保护级别组成，每个保护级别包含级别头部和负载组转到RTP payload中，如图2、3、4所示：

```c

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                RTP Header (12 octets or more)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    FEC Header (10 octets)                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      FEC Level 0 Header                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     FEC Level 0 Payload                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      FEC Level 1 Header                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     FEC Level 1 Payload                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Cont.                              |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

​                                                                         图2: FEC Packet Structure

FEC包的RTP头仅在发送受保护负载流的分割流中使用（在rfc5109 第14节定义）。图2中的RTP头由[RFC3550](https://www.ietf.org/rfc/rfc3550.txt)定义，以下几个字段需要特殊说明下：

Marker：该位不再这里使用，应该设置为0.

Synchronization Source（SSRC）：这里的值应该与所保护的媒体流里的SSRC值一致。

Sequence Number（SN）：该序列号具有标准定义-必须比先前发送的FEC数据包中的序列号高1.

Timestamp（TS）：时间戳必须在发送FEC数据包的那一刻设置为媒体RTP时钟值。因此，FEC包中的TS值总是单调增加。

Payload type：FEC数据包的有效负载类型通过动态确定，通过out-of-band手段。根据RFC3550[1]，无法识别有效负载类型的RTP参与者必须将其丢弃。这样就提供了向后兼容性。FEC机制可以被用在多播组的具有混合FEC和不具有FEC的接收器中，尤其是当FEC保护作为冗余编码发送时（在fgc5109第14节定义）。在这种情况下，FEC保护的有效载荷类型无法被支持FEC的接收器识别，因此将被忽略。

```c

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|L|P|X|  CC   |M| PT recovery |            SN base            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          TS recovery                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        length recovery        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

​                                                                                   图3:FEC Header Format

E：扩展位，暂不使用，设置为0.

L：指示是否使用长掩码（mask）。如果L未设置，则mask长度为16位。如果L设置了，则mask长度为48位。

P恢复字段，X恢复字段，CC恢复字段，M恢复字段和PT恢复字段是通过对RTP标头中的相应P，X，CC，M和PT值应用保护操作而获得的与FEC数据包相关的媒体数据包。

考虑到所有受FEC保护的媒体数据包的回绕（所有级别），SN基础字段必须设置为最低序号。这允许FEC操作在L字段设置为0时扩展到最多16个数据包的任何字符串，或者在L字段设置为1时扩展到48个数据包，等等。

通过应用于与该FEC分组相关联的媒体分组的时间戳的保护操作来计算TS恢复字段。这样可以完全恢复时间戳。

length Recovery 字段用于确定任何已恢复数据包的长度。CSRC列表，RTP extension和媒体有效负载数据包的填充（如果存在）被作为有效负载的一部分“计数”（以字节为单位）。 即使被保护的媒体分组的长度不同，这也允许应用FEC程序。 例如，假设通过将两个媒体分组异或在一起来生成FEC分组。 两个媒体数据包的有效负载长度分别为3（0b011）和5（0b101）字节，则length recovery字段就是ob011 xor ob101=ob110( 011 ^ 101=110)。

## 2.3 FEC包中的FEC Level头

```c
   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Protection Length       |             mask              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              mask cont. (present only when L = 1)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

​                                                                         图4:ULP Level Header Format

FEC Level头长度为4或8字节（依赖于FEC头的L位）。

FEC Level头由保护长度和mask字段组成。protection length占16位。mask字段占16位（当L未设置），或占48位（当L设置）。

FEC level头中的mask字段指示在当前级别哪些数据包与FEC数据包相关联。如果mask中的i位设置为1，则序列号为N+i的媒体数据包与此FEC数据包相关联，其中N是FEC数据包头中的SN Base字段。mask的最高有效位对应于i=0，当L设置为0时，最低位对应于i=15，或者当L设置为1时，i=47.

mask字段的设置必须遵循以下规则：

a. 媒体数据包在高于0级别的等级中只能被保护一次，但是可以在0级别中被多个FEC包保护，只要这些FEC包在0级别的保护长度相等。

b. 如果媒体数据包在p级别被保护，那么它也必须在p-1级别被保护。注意保护p级别的FEC包和保护p-1级别的FEC包可能不是同一个。

c. 如果FEC包包含p级别保护，那么它也必须包含p-1级别保护。注意p级别保护的数据包可能和p-1级别保护的数据包不是同一个。

原因：规则a，把多重保护限定在0级别，高于0级别的多重保护会减少保护效果并且增大接收端恢复数据的复杂度。规则b，限定媒体数据包受保护的连续性，即不存在中间某段数据不受保护的媒体数据包。规则c，限定FEC数据包保护级别的连续性，即不存在中间某个级别不保护数据的FEC数据包。

## 2.4 保护操作

   FEC数据包由受保护媒体RTP数据包的数据生成的“FEC位字符串”形成。进一步来说，FEC比特串是受保护媒体RTP分组的“受保护比特串”的按位异或。

  对于保护操作可以遵循以下步骤。也可以使用其他过程，但是最终结果必须与此处描述的过程相同。

###  2.4.1 生成FEC头

​	FEC头将为每个要在FEC level 0保护的媒体数据包生成受保护的位串（长度为80位）。它是通过按指定顺序将以下字段连接在一起而形成的。

- RTP头的前64位（64位）
- 媒体数据包长度的无符号网络排序16位表示形式，以字节减去12（RTP固定头）为单位，即以下所有内容的长度之和：CSRC list，extension header，RTP payload和RTP padding。（16位）

通过在受保护的位串上执行奇偶校验而形成FEC位串后，从FEC位串生成FEC头，如下所示：

FEC位串中的前两个（最高有效位）被跳过。FEC位串中的下一位写入FEC数据包中FEC头的P恢复位。接着下一位写入FEC头的E恢复位。接着写入4位的CC 恢复位。接着一位写入M恢复位。接着写入7位的PT恢复位。接着16位跳过。接着32位写入TS恢复位。接着写入16位 length 恢复位。

### 2.4.2 生成FEC payload

​	对于生成FEC payload，受保护的位串只是受保护的RTP数据包。因此，FEC位串是这些受保护媒体RTP数据的按位异或。由于每个级别的受保护有效载荷数据包的组可能不同，因此需要为每个级别生成此类FEC位串。如果受保护的RTP分组的长度不等，则必须在每个较短的分组末尾填充0字节到最长的分组长度。

​	对于保护级别n（n=0，1，...），仅将Ln个字节的数据设置为FEC level n有效载荷数据在 level n ULP头之后。数据是FEC位串中从第（Sn+13）个字节开始的数据的Ln字节，其中 Sn = sum(Li : 0 <= i < n)。

Li是级别i的保护长度，S0 被定义为0.省略前12字节的原因是该信息已经收到FEC头的保护。

## 2.5 恢复程序

​	FEC数据包允许终端系统从媒体数据包丢失中恢复。

​	恢复需要两个不同的操作。第一个确定必须合并那些数据包（媒体和FEC）才能恢复丢失的数据包。完成后，第二步是实际的重建数据。第二步必须如下所述之行。第一步可以基于实现者选择的任何算法。如果可能，不同的算法会在复杂性和恢复丢失数据包的能力间进行权衡。

​	由于不平等的错误保护的性质（使用时），根据数据丢失的情况，丢失的有效负载数据包可以全部或部分恢复。可以通过检查从FEC头中检索到的数据包的恢复长度和恢复的有效负载数据的实际长度，来检测数据包的部分数据。

###  2.5.1 重建RTP头

​	令T为可组合以恢复level 0的某些媒体数据包xi的数据包列表（FEC和媒体）。步骤如下：

1. 对于T中的媒体包，按照上一节中生成FEC头所述的步骤，计算受保护位串的前80位。
2. 对于T中的FEC包，FEC位串是80位FEC头。
3. 将恢复位串计算为从T中所有媒体数据包生成的受保护位串与T中所有FEC数据包生成的FEC位串按位异或。
4. 创建一个不含payload的 12字节的标准RTP头。
5. 将新数据包中的version设置为2。在恢复位串中跳过前2位。
6. 将新数据包中的padding位设置为恢复位串中的下一位。
7. 将新数据包中的extension位设置为恢复位串的下一位。
8. 将新数据包中的CC去设置为恢复位串的下4位。
9. 设置marker位为恢复位串的下一位。
10. 设置payload type对应恢复位串的下7位。
11. 设置SN域为xi。跳过恢复位串的下16位。
12. 设置TS域为恢复位串的下32位。
13. 获取恢复位串的下16位。无论它代表什么无符号整数（假设网络字节序）。从恢复位串中提取那么多字节，并将其附加到新数据包中。这表示CSRC列表，extension，payload，和RTP有效负载的padding。
14. 设置新包的SSRC为其保护的媒体流的SSRC，即与FEC流关联的媒体流的SSRC。

此过程将恢复RTP数据包的报头直到SSRC字段为止。

### 2.5.2 重建RTP payload

​	令T为可以组合起来以某种保护级别恢复某些数据包xi的数据包列表（FEC和媒体）。步骤如下：

1. 假设我们正在重建第n级数据，第一步就是在level n 的ULP头中获取保护级别长度（Ln）
2. 对于T中的FEC包，级别n的FEC位串是FEC级别n有效载荷，即级别n的ULP头之后的数据的Ln个字节。
3. 对于T中的媒体包，级别n的受保护位串是数据的Ln个字节，从数据包的第（Sn+13）个字节开始。Sn跟之前提到的相同。注意，级别0的保护从SSRC字段之后的媒体数据包的第13个字节开始。前12个字节的信息就是FEC保护头。
4. 如果从媒体数据包生成的级别n的任何受保护位串短于当前级别的保护长度，则将它们填充到该长度。在位串的末尾填充0字节。
5. 恢复位串的计算为从T中所有媒体数据包生成的n级受保护位串与从T中所有FEC数据包生成的n级别FEC位串按位异或。
6. 如上生成的当前保护级别的恢复位串通过与其他级别的恢复位串的级联而组合，以形成（全部或部分）恢复的媒体分组。注意，每个保护级别的恢复位串必须根据保护长度设置，放置在该级别的恢复媒体包中正确的位置。
7. 从恢复操作以恢复的媒体分组的保护等级0恢复恢复的媒体分组的总长度。此信息可用于检查（所有级别）完整恢复操作是否已经将数据恢复到完整长度。

## 2.6 例子

在下面考虑的两个示例中（2.6.1和2.6.2），我们假设FEC流式通过单独RTP会话发送的（在后续详解）。对于这些例子，我们假设将从SSRC2发送四个媒体数据包A、B、C和D。他们的序列号（sequence number）分别为8，9，10和11，并且时间戳（timestamps）分别为3，5，7和9。包A和C使用payload type 11，包B和D使用18。包A具有200字节的payload，包B为140字节，包C为100字节，包D为340字节。包A和C设置了它们的marker位。

第三个例子（2.6.3）说明了FEC数据何时与有效载荷数据包一起作为冗余数据发送。

### 2.6.1示例1（提供与RFC 2733类似的保护）

​	我们可以使用一个FEC数据包在一个级别中将四个有效负载数据包保护到完整长度，如图6所示。

```c
                    +-------------------+             :
         Packet A   |                   |             :
                    +-------------+-----+             :
         Packet B   |             |                   :
                    +---------+---+                   :
         Packet C   |         |                       :
                    +---------+-----------------------+
         Packet D   |                                 |
                    +---------------------------------+
                                                      :
                    +---------------------------------+
         Packet FEC |                                 |
                    +---------------------------------+
                    :                                 :
                    :<------------- L0 -------------->:
```

​                                                     图6:FEC scheme with Single-Level protection

​	根据这四个数据包生成FEC数据包，我们假设payload type 127用于指示FEC数据包。

最后的RTP头如图7所示。

FEC包中的FEC头如图8所示。

FEC level头的level 0 如图9所示。

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|0|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    0
      PT:        127
      SN:        1
      TS:        9
      SSRC:      2
```

​                                                                 图7: RTP header of FEC packet

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 1 1 1 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   0     [11 XOR 18 XOR 11 XOR 18]
      SN base:   8     [min(8,9,10,11)]
      TS rec.:   8     [3 XOR 5 XOR 7 XOR 9]
      len. rec.: 372   [200 XOR 140 XOR 100 XOR 340]
```

​                                                             图8: FEC Header of FEC packet

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L0:        340   [the longest of 200, 140, 100, and 340]
      mask:      61440 [with Bits 1, 2, 3, and 4 marked accordingly for
                        Packets 8, 9, 10, and 11]

      The payload length for level 0 is 340 bytes.
```

​                                                              图9: FEC Level Header（Level 0）

### 2.6.2 示例二（两个保护级别）

​	一个更复杂的示例是在两个级别上使用FEC。level 0 FEC将为有效载荷的开始部分提供更大的保护。level 1 FEC将对其余数据包应用额外的保护。如图10所示，在这个例子中，L0 = 70 且 L1 = 90.

```c
              +------:--------:---+
   Packet A   |      :        :   |
              +------:------+-:---+
   Packet B   |      :      | :
              +------:--+---+ :
                     :        :
              +------+        :
   ULP #1     |      |        :
              +------+        :
                     :        :
              +------:--+     :
   Packet C   |      :  |     :
              +------:--+-----:-----------------+
   Packet D   |      :        :                 |
              +------:--------:-----------------+
                     :        :
              +------:--------+
   ULP #2     |      :        |
              +------:--------+
              :      :        :
              :<-L0->:<--L1-->:
```

​                                                图10：ULP FEC scheme with protection Level 0 and Level 1

ULP FEC packet #1 的RTP头如图11所示。 ULP FEC packet #1 的FEC头如图12所示。 level 0 ULP 头 for #1 如图13所示。

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    1
      PT:        127
      SN:        1
      TS:        5
      SSRC:      2
```

​                                                                图11: RTP Header of FEC Packet #1

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   25    [11 XOR 18]
      SN base:   8     [min(8,9)]
      TS rec.:   6     [3 XOR 5]
      len. rec.: 68    [200 XOR 140]
```

​                                                       图12: FEC Header of ULP FEC Packet #1

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L0:        70
      mask:      49152 [with Bits 1 and 2 marked accordingly for
                        Packets 8 and 9]

      The payload length for level 0 is 70 bytes.
```

​                                             图13: FEC level Header（Level 0）for FEC Packet #1 

FEC packet #2的RTP头如图14所示。FEC 头 for FEC packet #2 如图15所示。level 0 ULP header for #2 如图16所示。level 1 ULP header for #2 如图17所示。

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    1
      PT:        127
      SN:        2
      TS:        9
      SSRC:      2
```

​                                                             图14: RTP header of FEC Packet #2

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   25    [11 XOR 18]
      SN base:   8     [min(8,9,10,11)]
      TS rec.:   14    [7 XOR 9]
      len. rec.: 304   [100 XOR 340]
```

​                                                                 图15: FEC header of FEC Packet #2

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L0:        70
      mask:      12288 [with Bits 3 and 4 marked accordingly for
                        Packets 10 and 11]

      The payload length for level 0 is 70 bytes.
```

​                                                      图16: FEC Level Header（Level 0） for FEC Packet #2

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L1:        90
      mask:      61440 [with Bits 1, 2, 3, and 4 marked accordingly for
                        Packets 8, 9, 10, and 11]

      The payload length for level 1 is 90 bytes.
```

​                                           图17: FEC Level Header（Level 1）for FEC Packet #2

### 2.6.3 示例三（以FEC作为冗余编码）

​	我们假设将从SSRC 2发送5个媒体数据包A、B、C、D和E。他们的sequence numbers 分别为8，9，10，11和12，且 teimestamps 分别为3，5，7，9和11. 所有的媒体数据都是用主要编码进行编码（FEC因为冗余编码仅保护主要编码）并使用payload type为11。包A的有效载荷具有200字节，B有140，C有100，D有340，E有160。包A和C设置了marker位。我们使用FEC一级方案如2.6.1节中图6所示。保护长度L0 = 340字节。

有效负载类型为100的冗余编码打包。FEC的payload type假设设置为127。前面4个RED包，RED #1 至RED #4，每个都包含一个单独的媒体数据包A、B、C或D。FEC数据由为保护前四个媒体数据包生成。而第5个包 RED #5 与媒体数据包E一起包含此FEC数据作为冗余编码。

```
   RED Packet #1:    Media Packet A
   RED Packet #2:    Media Packet B
   RED Packet #3:    Media Packet C
   RED Packet #4:    Media Packet D
   RED Packet #5:    FEC Packet, Media Packet E
```

从RED 包 #1 到 #4 具有的结构如图18所示。 RTP header of RED packet #1 如图19所示，与其他RED数据包的格式相似，带有相应的序号和时间戳。主要编码块的RED数据包头如图20所示。

```c
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 RTP Header (RED) - 6 octets                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Primary Encoding Block Header (RED) - 1 octet          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Media Packet Data                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

​                                                       图18: RED Packet Structure - Media Data Only

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|0|1 1 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    0     [Even though media packet A has marker set]
      PT:        100   [Payload type for RED]
      SN:        1
      TS:        5
      SSRC:      2
```

​                                                                   图19: RTP Header of RED Packet #1

```c
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|0 0 0 1 0 1 1|
   +-+-+-+-+-+-+-+-+

      F bit:     0     [This is the primary coding data]
      Block PT:  11    [The payload type of media]
```

​                                                                 图20: Primary Encoding Block Header

FEC数据不是直接从RED包中生成，而是从包含媒体包数据的虚拟RTP包中生成。无论是否包含冗余编码，这些虚拟RTP包都可以很容易地从RED包中生成。从RED包到虚拟RTP包的转换只需通过（1）删除所有RED块头和冗余编码数据，以及（2）用主编码的PT替换RTP头中的PT即可。

注意： 在RFC 2198中指定的冗余编码的有效载荷格式中，一旦在RED包中进行了主编码，标记位就会丢失。因此，无论是否使用FEC，都无法恢复标记位。

如上所述，RED包 #5将包含FEC 数据（保护媒体包A、B、C和D）以及媒体包E的数据。RED 包#5的结构如图21所示：

```c
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 RTP Header (RED) - 6 octets                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Redundant Encoding Block Header (RED) - 4 octets        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        FEC Packet Data                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Primary Encoding Block Header (RED) - 1 octet          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Media Packet Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

​                                                     图21: RED Packet Structure - With FEC Data

包含FEC的RED包的RTP头与图19相同，并带有相应的序列号和时间戳。

在RED packet #5中，FEC包数据块的冗余编码块头如图22所示。紧随其后的是FEC包数据，在这种情况下，该数据包括FEC头（如图8所示的10字节），ULP level 0头（如图9所示的4字节）和ULP level 0 数据（为level 0 设置的340字节）。这些之后是包含媒体包E数据的主要编码。

```c
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 1 0 1 1 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      F bit:     1     [This is the redundant coding data]
      Block PT:  127   [The dynamic payload type for FEC]
      TS Offset: 0     [The instance at which the FEC data is
                        transmitted]
      Block Len: 354   [FEC header (10 octets) plus ULP level 0 header
                        (4 octets) and ULP level 0 data (340 octets)]
```

​                                                        图22: Redundant Encoding Block Header

## 2.7 FEC复用

​	FEC包可以与受保护的有效载荷一起通过以下两种方式之一发送给接收方：1. 作为独立的流，2. 与冗余编码在同一个流中。配置选项必须带外指示。本节描述如何使用RFC2327[8]中指定的绘画描述协议（SDP）来完成此操作。

### 2.7.1 FEC作为独立流

​	FEC作为独立流，必须传达几条信息：

- FEC被发送到的地址和端口
- FEC的有效负载类型编号
- FEC保护的哪个媒体流

因为FEC没有静态有效负载类型分配，因此动态有效负载类型编号必须被使用。FEC流的SSRC必须设置成被保护有效负载流的SSRC。FEC流与其对应流的关联是通过SDP[5]中具有FEC语义[6]的行分组或其他外部方式完成的。

​	遵循RFC 3550 [1]第5.2节中讨论的原理，FEC流及其关联的有效负载流的多路复用通常由目标传输地址（网络地址和端口号）提供，这对于每个RTP会话都是不同的，在单个RTP会话中将FEC与有效载荷一起发送，并且仅通过SSRC或有效载荷类型进行多路传输会排除以下情况：（1）为有效负载和FEC保护数据使用不同的网络路径或网络资源分配；（2）接收媒体的子集，如果需要的话，尤其是对于那些不了解FEC的主机；（3）对不同媒体使用单独过程的接收器实现。另外，将FEC与有效载荷数据流复用将影响原始有效载荷流的计时和序列号空间，这通常是不希望的。因此，应通过两个单独的RTP会话发送FEC流和有效负载流，并应避免按有效负载类型将它们多路复用到一个单独的RTP会话中。此外，FEC和有效负载不得由SSRC复用为一个RTP会话，因为它们始终具有相同的SSRC。

​	就像任何媒体流一样，FEC流的端口号和有效负载类型号在SDP中的m行中传送。FEC没有静态有效载荷类型分配，因此必须使用动态有效载荷类型编号。与数字的绑定由rtpmap属性指示。 该绑定中使用的名称是“ ulpfec”。FEC流所在的地址在其对应的c行中传送。

​	使用FEC语义（RFC 4756）[6]，通过SDP（RFC 3388）[5]中的媒体行分组来传达FEC流与其保护的有效负载流之间的关联关系。FEC流和受保护的有效载荷流形成FEC组。以下是在多播会话中用于FEC应用程序的示例SDP：

```c
       v=0
       o=adam 289083124 289083124 IN IP4 host.example.com
       s=ULP FEC Seminar
       t=0 0
       c=IN IP4 224.2.17.12/127
       a=group:FEC 1 2
       a=group:FEC 3 4
       m=audio 30000 RTP/AVP 0
       a=mid:1
       m=application 30002 RTP/AVP 100
       a=rtpmap:100 ulpfec/8000
       a=mid:2
       m=video 30004 RTP/AVP 31
       a=mid:3
       m=application 30004 RTP/AVP 101
       c=IN IP4 224.2.17.13/127
       a=rtpmap:101 ulpfec/8000
       a=mid:4
```

此SDP中存在两个a = group行表示存在两个FEC组。如“ a = group：FEC 1 2”行所示，第一个FEC组由流1（使用PCM [14]的音频流）和流2（保护FEC流）组成。FEC流被发送到相同的多播组，并且具有与音频相同的生存时间（TTL），但是端口号高两个。如“ a = group：FEC 3 4”行所示，第二个FEC组由流3（视频流）和流4（保护FEC流）组成。FEC流被发送到不同的多播地址，但是具有与有效载荷视频流相同的端口号（30004）。

### 2.7.2 FEC作为冗余编码

​	当FEC流作为冗余编码格式发送时，必须通过SDP发出信号。为此，使用RFC 2198 [7]中定义的过程来表示使用冗余编码。FEC有效载荷类型的指示方式与其他任何辅助编解码器相同。FEC务必仅保护主编解码器，FEC引擎的有效载荷来自根据主编解码器数据创建的虚拟RTP数据包。通过简单地（1）删除所有附加标头和冗余编码数据，以及（2）用主编解码器替换RTP标头中的有效负载类型，可以非常容易地从RFC 2198数据包转换虚拟RTP数据包。

注意：在RFC 2198指定的用于冗余编码的有效载荷格式中，一旦在RED数据包中进行了主编码，标记位就会丢失。 因此，无论是否使用FEC，都无法恢复标记位。

​	由于FEC数据（包括ULP标头）是在与受保护有效负载相同的数据包中发送的，因此FEC数据通过捆绑在同一流中而与受保护有效负载相关联。

​	当FEC流以冗余编码格式作为辅助编解码器发送时，可以通过SDP发出信号。为此，使用RFC 2198 [7]中定义的过程来表示使用冗余编码。FEC有效载荷类型的指示方式与其他任何辅助编解码器相同。rtpmap属性必须用于指示FEC数据包的动态有效载荷类型编号。 FEC必须仅保护主编解码器。

例如：

```c
      m=audio 12345 RTP/AVP 121 0 5 100
      a=rtpmap:121 red/8000/1
      a=rtpmap:100 ulpfec/8000
      a=fmtp:121 0/5/100
```

此SDP指示存在单个音频流，该音频流可以包括PCM（媒体格式0），DVI（媒体格式5），冗余编码（由媒体格式121表示，通过rtpmap属性绑定为红色）， 或FEC（媒体格式100，通过rtpmap属性绑定到ulpfec）。尽管FEC格式被指定为该流的可能编码，但是FEC绝不能为该流本身发送。仅因为必须根据RFC 2198在此处列出非主要编解码器，才要求其在m行中存在。fmtp属性指示可以使用冗余编码格式，其中DVI作为第二级编码，而FEC作为第三级编码。

### 2.7.3 Offer/Answer

​	当使用SDP的offer/answer[15]交换时，需要考虑一些注意事项。“ onelevelonly”参数是声明性的。 对于声明为sendonly的流，该值指示是否仅发送一级FEC。 对于声明为recvonly或sendrecv的流，该值指示接收方接受接收的内容。

​	当FEC作为单独的流发送并使用FEC语义（RFC 4756）[6]通过SDP（RFC 3388）[5]中的媒体线路分组发送信号时，提供方必须同时实现RFC 3388和RFC 4756。RFC 3388和RFC 4756中offer/answer的规则应遵循以下附加注意事项。对于所有带有FEC的提议，answerer可以通过将端口设置为0来拒绝单独的FEC会话，并删除将该FEC会话与受保护的RTP会话进行分组的“ a = group”属性。如果应答者接受FEC的使用，则answerer只需在答案中包含相同的分组，即可接受FEC RTP会话和answer中的分组。注意，拒绝FEC RTP会话不会阻止媒体会话在没有FEC的情况下被接受和使用。

​	当以冗余编码格式（RFC 2198）[7]将FEC流作为辅助编解码器发送时，提供方可以指示第2.7.2节中指定的FEC流。answerer可以通过删除FEC流的有效载荷类型来拒绝FEC流。要接受FEC的使用，answerer必须在answer中包括FEC有效载荷类型。注意，在冗余有效载荷格式[7]与FEC一起用作唯一的辅助编解码器的情况下，当拒绝FEC流时，也应删除冗余编码有效载荷类型。