# RTP/RTCP

​	基于[rfc3550](https://www.ietf.org/rfc/rfc3550.txt)整理

# 6. RTCP（RTP Control Protocol）

​	RTCP是基于向会话中的所有参与者定期发送控制包，并使用与数据包相同的分发机制。底层协议务必（例如，使用带有UDP的单独端口号）提供数据和控制包的复用。RTCP执行四个功能：

1. 主要功能是提供有关数据分发质量的反馈。这是RTP作为传输协议角色不可或缺的一部分，并且与其他传输协议的流和拥塞控制功能有关（请参阅后面章节，了解拥塞控制）。反馈对于控制自适应编码可能是直接有用的rfc3550[18,19]，但是IP多播的实验表明，从接收器获得反馈以诊断配电故障也是至关重要的。将接收反馈报告发送给所有参与者，可以让正在观察问题的人评估这些问题是本地的还是全局的。使用像IP多播这样的分发机制，不参与会话的诸如网络服务提供商之类的实体也有可能接收反馈信息，并充当第三方监视器来诊断网络问题。该反馈功能由RTCP发送方和接收方报告执行，如下面第6.4节所述。
2. RTCP带有RTP源的持久性传输级别标识符，称为规范名称或CNAME，第6.5.1节。由于如果发现冲突或重新启动程序，SSRC标识符可能会更改，因此接收方要求CNAME跟踪每个参与者。接收方还可能要求CNAME将来自给定参与者的多个数据流关联到一组相关的RTP会话中，例如，以同步音频和视频。媒体间同步还要求数据发送者将RTCP数据包中包含的NTP和RTP时间戳记。
3. 前两个功能要求所有参与者都发送RTCP数据包，因此必须控制速率，以使RTP扩展到大量参与者。通过让每个参与者将其控制包发送给所有其他参与者，每个参与者都可以独立观察参与者的数量。如第6.2节所述，此数字用于计算数据包的发送速率。
4. 第四个可选功能是传达最少的会话控制信息，例如要在用户界面中显示的参与者标识。这在参与者没有成员资格控制或参数协商的情况下进入和离开的“松散控制(loosely controlled)”会话中很有用。RTCP是到达所有参与者的便捷通道，但不一定期望它支持应用程序的所有控制通信要求。可能需要更高级别的会话控制协议，这超出了本文的范围。

功能1～3点应该被应用在所有环境中，尤其是IP 多播环境。RTP应用程序设计者应避免只能在单播模式下工作且无法扩展为更大数量的机制。如第6.2节所述，对于单向链路等无法从接收器反馈的情况，可以为发送者和接收者分别控制RTCP的传输。

已知的非标准：在称为特定于源的组播（SSM）的组播路由方法中，每个“通道”（源地址，组地址对）只有一个发送者，并且接收者（通道源除外）不能使用组播直接通过渠道成员与其他发送者进行通信。这里的建议仅通过第6.2节完全关闭接收器的RTCP的选项来容纳SSM。将来将会特别适配SSM的RTCP，以便可以保持来自接收者的反馈。

## 6.1 RTCP包格式

​	该规范定义了几种RTCP数据包类型，以承载各种控制信息：

SR：Sender report，用于来自活动发送者的发送和接受统计信息。

RR：Receiver report，用于来自非活跃发件人的参与者的接收统计信息，以及与SR结合使用的活跃发件人的报告超过31个来源。

SDES：来源描述项，包括CNAME。

BYE：表示参与结束。

APP：特定于应用的功能。

​	每个RTCP数据包都以类似于RTP数据包的固定部分开头，然后是结构化元素，结构化元素的长度根据数据包类型而定，但必须在32位边界上结束。每个数据包固定部分的对齐要求和长度字段都包括在内，以使RTCP数据包“可堆叠”。可以串联多个RTCP数据包，而无需任何中间的分隔符，以形成一个复合RTCP数据包，该数据包在较低层协议（例如UDP）的单个数据包中发送。复合分组中没有明确的单个RTCP分组计数，因为预计下层协议将提供确定复合分组结尾的总长度。

​	复合数据包中的每个单独的RTCP数据包都可以独立处理，而对数据包的顺序或组合没有任何要求。但是，为了执行协议的功能，施加了以下约束：

- 接收统计信息（在SR或RR中）应尽可能频繁地发送，因为带宽限制将允许最大化统计信息的分辨率，因此，每个定期发送的复合RTCP数据包务必包括一个报告数据包。
- 新的接收者需要尽快接收源的CNAME以便识别源并开始为诸如口形同步之类的目的关联媒体，因此每个复合RTCP数据包还必须包括SDES CNAME，除非分离复合RTCP数据包时 进行第9.1节所述的部分加密。
- 需要限制可能首先出现在复合数据包中的数据包类型的数量，以增加第一个字中的恒定位的数量以及针对错误寻址的RTP数据包或其他不相关的数据包成功验证RTCP数据包的可能性。

因此，所有RTCP数据包务必以至少两个单独的数据包的复合数据包的形式发送，格式如下：

Encryption prefix：加密前缀，当且仅当要根据第9.1节中的方法对复合数据包进行加密时，必须为每个传输的复合数据包重新绘制一个随机的32位量作为前缀。 如果加密需要填充，则必须将其添加到复合数据包的最后一个数据包中。

SR or RR：复合数据包中的第一个RTCP数据包必须始终是一个报告数据包，以促进报头验证，如附录A.2所述。 即使没有发送或接收任何数据（在这种情况下，必须发送一个空的RR），并且即使复合数据包中唯一的其他RTCP数据包是BYE，也是如此。

Additional RRs：如果要报告其接收统计信息的源数目超过31个（将适合一个SR或RR数据包的数目），则应在初始报告数据包之后附加RR数据包。

SDES：除第9.1节所述外，每个复合RTCP包中都必须包括一个包含CNAME项的SDES包。 如果特定应用需要，则可以选择包含其他源描述项，但要遵守带宽限制（请参阅第6.3.9节）。

BYE or APP：其他RTCP数据包类型，包括尚未定义的RTCP数据包类型，可以按任何顺序排列，但BYE应该是用给定SSRC / CSRC发送的最后一个数据包。 包类型可能出现多次。

​	单个RTP参与者应在每个报告间隔仅发送一个复合RTCP数据包，以便正确估计每个参与者的RTCP带宽（请参阅第6.2节），除非如第9.1节所述将复合RTCP数据包拆分为部分加密。如果有太多的资源无法将所有必要的RR数据包放入一个复合RTCP数据包中，而又不超过网络路径的最大传输单位（MTU），则每个时间间隔应仅包括适合一个MTU的子集。 应该在多个时间间隔内循环选择子集，以便报告所有来源。

​	建议转换器和混合器在可行的情况下将它们从多个源转发的单个RTCP数据包组合成一个复合数据包，以分摊数据包开销（请参阅第7节）。图1显示了可能由混合器产生的示例RTCP复合数据包。如果复合数据包的总长度超过网络路径的MTU，则应将其分段为多个较短的复合数据包，以在基础协议的单独数据包中进行传输。这不会影响RTCP带宽估计，因为每个复合数据包代表至少一个不同的参与者。 请注意，每个复合数据包务必以SR或RR数据包开头。实现者应该忽略类型未知的RTCP包。如第15节所述，其他RTCP数据包类型可以向互联网号码分配机构（IANA）注册。

```c
  if encrypted: random 32-bit integer
   |
   |[--------- packet --------][---------- packet ----------][-packet-]
   |
   |                receiver            chunk        chunk
   V                reports           item  item   item  item
   --------------------------------------------------------------------
   R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
   --------------------------------------------------------------------
   |                                                                  |
   |<-----------------------  compound packet ----------------------->|
   |<--------------------------  UDP packet ------------------------->|

   #: SSRC/CSRC identifier
```

​                                                           图1:Example of an RTCP compound packet

## 6.2 RTCP 传输间隔

​	RTP旨在允许应用程序自动扩展会话规模，参与者人数从几到数千不等。例如，在音频会议中，数据流量本质上是自我限制的，因为一次只能讲话一个或两个人，因此在多播分发中，任何给定链路上的数据速率都保持相对恒定，而与参与者的数量无关。但是，控制流量不是自限的。如果每个参与者的接收报告以恒定的速率发送，则控制流量将随参与者的数量线性增长。 因此，必须通过动态计算RTCP数据包传输之间的间隔来缩小速率。

​	对于每个会话，假定数据流量受到称为“会话带宽”的限制，该限制将在参与者之间分配。该带宽可以被保留，并且网络可以限制该限制。如果没有保留，则取决于环境，可能存在其他限制，这些限制为会话使用建立了“合理的”最大值，这将是会话带宽。可以基于会话的可用网络带宽的一些成本或先验知识来选择会话带宽。这依赖于媒体编码，它在某种程度上与媒体编码无关，但是编码选择可能会受到会话带宽的限制。通常，会话带宽是预期同时处于活动状态的发送者的标称带宽之和。对于电话会议音频，此数字通常是一个发送者的带宽。 对于分层编码，每一层都是具有其自己的会话带宽参数的单独的RTP会话。

​	会话管理应用程序调用会话应用程序时，应期望它提供会话带宽参数，但是媒体应用程序可以根据为会话选择的编码的单发送者数据带宽设置默认值。该应用程序还可以基于多播作用域规则或其他标准来实施带宽限制。 所有参与者必须为会话带宽使用相同的值，以便将计算相同的RTCP间隔。

​	带宽计算控制和数据流量包括底层的传输和网络协议（例如UDP和IP），因为这是资源预留系统需要知道的。应用程序还可以期望知道哪些正在使用这些协议。不计算链接级别的标头，因为数据包在传输时将呗同步的链接级别标头封装。

​	流量控制应限制在会话带宽的一小部分，即已知的部分：小到以免损坏传输协议传输数据的主要功能；以便流量控制可以包含在分配给资源预留协议的带宽规范中，并且每个参与者都可以独立计算其份额。流量带宽控制是数据流量的会话带宽的补充。建议将为RTCP添加的会话带宽的比例固定为5%。也建议将RTCP带宽的1/4专用于正在发送数据的参与者，以便在具有大量接收者但发送者数量少的会话中，新加入的参与者将更快的接收发送站点的CNAME。当发送方的比例大于参与者的1/4时，发送方将获得其全部RTCP带宽的比例。虽然间隔计算中的这些常数和其他常数的值并不严格，但会话中的所有参与者都必须使用相同的值，因此将计算相同的间隔。因此，这些常数应针对特定配置文件而固定。

​	一个配置文件可以规定控制业务带宽可以是会话的一个单独的参数，而不是会话带宽的严格百分比。 使用单独的参数允许速率自适应应用程序设置与“典型”数据带宽一致的RTCP带宽，该“典型”数据带宽低于会话带宽参数指定的最大带宽。简表可以进一步规定，对于那些是活跃数据发送者和不是活跃数据发送者的参与者，控制业务带宽可以分为两个单独的会话参数； 让我们将参数称为S和R。遵循将RTCP带宽的1/4专用于数据发送器的建议，这两个参数的RECOMMENDED默认值分别为1.25％和3.75％。当发送方的比例大于参与者的S /（S + R）时，发送方将获得这些参数之和的比例。通过使用两个参数，可以通过将非数据发送者的RTCP带宽设置为零，同时将数据发送者的RTCP带宽保持为非零，从而完全关闭特定会话的RTCP接收报告，以便发送者报告仍可以在内部发送。 在媒体间同步。建议不要关闭RTCP接收报告，因为第6节开头列出的功能需要使用RTCP接收报告，尤其是接收质量反馈和拥塞控制。 但是，这样做可能适合于在单向链路上运行的系统，或者对于不需要反馈有关接收质量或接收器状态的反馈并且具有其他避免拥塞的方式的会话。

​	复合RTCP数据包传输之间的计算间隔也应有一个下限，以避免在参与者数量少并且流量没有根据大数定律进行平滑时，突发数据包超过允许的带宽。它还可以防止报告间隔在瞬态中断（如网络分区）期间变得过小，从而在分区修复后延迟适应。 在应用程序启动时，应该在发送第一个复合RTCP数据包之前施加延迟，以允许有时间从其他参与者接收RTCP数据包，因此报告间隔将更快地收敛到正确的值。可以将这个延迟设置为最小间隔的一半，以便更快地通知新的参与者在场。 固定最小间隔的推荐值为5秒。

​	一个实现可以将最小RTCP间隔按比例缩小到与会话带宽参数成反比的较小值，但有以下限制：

- 对于多播会话，只有活动数据发送者可以使用减小的最小值来计算复合RTCP数据包的传输间隔。
- 对于单播会话，减小的值也可以由不是活动数据发送者的参与者使用，并且在发送初始复合RTCP数据包之前的延迟可以为零。
- 对于所有会话，在计算参与者超时间隔时（请参见第6.3.5节），应使用固定的最小值，以便其他参与者不会过早地将不使用减小的值来传输RTCP数据包的实现方式超时。
- 减少的最小值（以秒为单位，360划分）的RECOMMENDED值除以会话带宽（以千位/秒为单位），单位为秒。 对于大于72 kb / s的带宽，此最小值小于5秒。

​	6.3节和附录A.7中描述的算法旨在满足本节中概述的目标。 它计算发送复合RTCP数据包之间的间隔，以在参与者之间分配允许的控制流量带宽。这允许应用程序为小型会话提供快速响应，例如，识别所有参与者很重要，但自动适应大型会话。 该算法具有以下特征：

- RTCP数据包之间的计算间隔与组中成员的数量成线性比例关系。 当所有成员相加时，正是这种线性因素允许恒定数量的控制流量。
- RTCP数据包之间的间隔在计算的间隔的[0.5,1.5]倍的范围内随机变化，以避免所有参与者的意外同步[20]。 加入会话后发送的第一个RTCP数据包也会延迟最小RTCP间隔的一半的随机变化。
- 计算平均复合RTCP数据包大小的动态估计，包括所有已接收和发送的数据包，以自动适应所携带的控制信息量的变化。
- 由于计算的时间间隔取决于观察到的组成员的数量，因此当新用户加入现有会话或许多用户同时加入新会话时，可能会产生不良的启动效果。 这些新用户最初将对组成员身份有不正确的估计，因此，他们的RTCP传输间隔将太短。 如果许多用户同时加入会话，则此问题可能很严重。为了解决这个问题，采用了一种称为“计时器重新考虑”（timer reconsideration）的算法。 该算法实现了一种简单的退避机制，如果组大小增加，则该机制会使用户阻止RTCP数据包传输。
- 当用户通过BYE或超时退出会话时，组成员身份会减少，因此计算的间隔应减少。 “反向重新考虑”（reverse reconsideration）算法用于允许成员响应组成员身份减少而更快地减少其间隔。
- BYE数据包与其他RTCP数据包的处理方式有所不同。 当用户离开组并希望发送BYE数据包时，可以在下一个调度的RTCP数据包之前发送。 但是，BYE的传输遵循一种退避算法，该算法可以避免在大量成员同时离开会话的情况下BYE数据包泛滥的情况。

​	该算法可以用于允许所有参与者发送的会话。 在这种情况下，会话带宽参数是单个发送者的带宽乘以参与者数量的乘积，而RTCP带宽是该值的5％。

该算法的操作细节在以下各节中给出。 附录A.7给出了一个示例实现。

### 6.2.1 保持会话成员数量

​	RTCP数据包间隔的计算取决于参与会话的站点数量的估计。 当听到新站点时，会将它们添加到计数中，并应在由SSRC或CSRC标识符索引的表中创建每个站点的条目（请参见8.2节）以跟踪它们。 在接收到多个带有新SSRC的数据包之前（见附录A.1），或者在收到包含该SSRC的CNAME的SDES RTCP数据包之前，新条目可能被认为是无效的。当收到具有相应SSRC标识符的RTCP BYE数据包时，可以从表中删除条目，除了一些散乱的数据包可能在BYE之后到达并导致重新创建该条目之外。 相反，应将条目标记为已收到BYE，然后在适当的延迟后将其删除。

​	如果在少量RTCP报告间隔内未收到任何RTP或RTCP数据包（建议5个），则参与者可以将另一个站点标记为不活动，或将其删除（如果尚未生效）。 这提供了一些抗丢包的鲁棒性。 所有站点的此乘数必须具有相同的值，并且必须为RTCP报告间隔计算大致相同的值，以使此超时正常工作。因此，该乘数应针对特定配置文件而固定。

​	对于具有大量参与者的会话，维护一个表来存储所有参与者的SSRC标识符和状态信息可能是不切实际的。 一个实现可以使用<u>SSRC采样，如[21]中所述</u>，以减少存储需求。 一个实现可以使用任何其他具有类似性能的算法。 一个关键的要求是，尽管算法可能会高估，但任何考虑的算法都不应实质上低估组的大小。

## 6.3 RTCP包发送和接收规则

​	此处概述了如何发送规则以及接收RTCP数据包时的操作规则。 允许在多播环境或多点单播环境中运行的实现必须满足6.2节的要求。 这样的实现可以使用本节中定义的算法来满足那些要求，或者可以使用其他某种算法，只要它提供同等或更好的性能即可。 仅限于两方单播操作的实现仍应使用RTCP传输间隔的随机化，以避免在相同环境中运行的多个实例的意外同步，但可以在6.3节中省略“计时器重新考虑”和“反向重新考虑”算法参见6.3.3、6.3.6和6.3.7章节。

​	要执行这些规则，会话参与者必须保持几种状态：

tp: 上次发送RTCP包的时间；

tc: 当前时间；

tn: 下次RTCP包调度传输时间；

pmembers: 上次重新计算tn时的估计会话成员数；

members: 会话成员数的最新估计；

senders: 会话中发送方人数的最新估计；

rtcp_bw: 目标RTCP带宽，即此会话的所有成员将用于RTCP包的总带宽，以8b/s为单位。这将是启动时提供给应用程序的“会话带宽”参数的指定分数；

we_sent: 如果在发送第二个RTCP报告前已经发送数据，则此标记为true；

avg_rtcp_size: 此参与者发送和接收的所有RTCP数据包的平均复合RTCP数据包大小（以八位字节为单位）。 大小包括第6.2节中所述的下层传输和网络协议标头（例如UDP和IP）。

initial: 如果应用程序尚未发送RTCP数据包，则为true的标志。

### 6.3.1 计算RTCP传输间隔

​	为了保持可伸缩性，来自会话参与者的数据包之间的平均间隔应与组大小成比例。 此间隔称为计算间隔。 它是通过组合上述多个状态获得的。 然后，计算得出的间隔T如下确定：

1. 如果发送方数量小于或等于25%的会话成员（members），则时间间隔取决于参与者是否为发送方，基于we_sent的值。如果参与者是发送者（we_sent为true），则将常数C设置为平均RTCP数据包大小（avg_rtcp_size)除以RTCP带宽（rtcp_bw)的25%，并将常数n设置为发送者的数量。如果we_sent是false，则将常数C设置为平均RTCP数据包大小除以RTCP带宽的75%。常数n设置为接收方（members-senders）的数量。如果发送方人数量大于25%，则发送方和接收方一起对待。常数C设置为平均RTCP数据包大小除以总RTCP带宽，n设置为成员总数。如第6.2节所述，RTP简表可以规定RTCP带宽可以由两个单独的参数（分别称为S和R）明确定义，这些参数分别是发送方和非发送方。在这种情况下，25%的分数变为S/（S+R），而75%的分数变为R/（S+R）。注意，如果R为零，则发送方的百分比永远不会大于S/（S+R），并且实现必须避免被零除。
2. 如果参与者尚未发送RTCP数据包（变量initial为true），则常数Tmin设置为2.5秒，否则设置为5秒。
3. 确定性计算间隔Td设置为max(Tmin，n*C)。
4. 将计算间隔T设置为在确定性计算间隔的0.5至1.5倍之间均匀分布的数字。
5. T的结果值除以e-3/2=1.21828（e：自然常数），以补偿计时器重新考虑算法收敛到低于预期平均值的RTCP带宽值的事实。

​	此过程会导致一个随机间隔，但平均而言，该间隔至少将RTCP带宽的25％提供给发送方，其余部分则提供给接收方。 如果发送方构成成员资格的四分之一以上，则此过程平均将带宽平均分配给所有参与者。

### 6.3.2 Initialization

​	加入会话后，参与者将tp初始化为0，将tc初始化为0，将发件人初始化为1，将成员初始化为1，将we_sent发送为false，将rtcp_bw初始化为会话带宽的指定部分，初始为true，将avg_rtcp_size初始化为应用程序稍后将构造的第一个RTCP数据包的大概大小。然后计算出计算出的间隔T，并为时间tn = T调度第一个数据包。这意味着设置了一个传输计时器，该传输计时器在时间T到期。注意，应用程序可以使用任何所需的方法来实现此计时器。

​	参与者将自己的SSRC添加到成员表中。

### 6.3.3 接收RTP或Non-BYE RTCP包

​	当从其成员表中未包含SSRC的参与者接收到RTP或RTCP数据包时，将SSRC添加到表中，并且如第6.2.1节中所述验证了参与者后，将更新成员的值。 对于经过验证的RTP数据包中的每个CSRC，都会进行相同的处理。

​	当从发送方表中未包含SSRC的参与者接收到RTP数据包时，会将SSRC添加到表中，并更新发送方的值。

​	对于收到的每个复合RTCP数据包，avg_rtcp_size的值都会更新：

```c++
avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size
```

其中packet_size是刚接收到的RTCP数据包的大小。

### 6.3.4 接收RTCP BYE数据包

​	除了要发送RTCP BYE的情况（如6.3.7节所述）外，如果接收的数据包是RTCP BYE数据包，则针对成员表检查SSRC。 如果存在，则从表中删除该条目，并更新成员的值。 然后对照发件人表检查SSRC。 如果存在，则从表中删除该条目，并更新发件人的值。

​	此外，为了使RTCP数据包的传输速率更适应组成员资格的变化，当接收到BYE数据包将成员的值减少到小于pmembers时，应执行以下“反向重新考虑”算法：

- tn的值根据以下公式更新：

  ```c++
  tn = tc + (members/pmembers) * (tn - tc)
  ```

- tp的值更具以下公式更新：

  ```c++
  tp = tc - (members/pmembers) * (tc - tp)
  ```

- 下一个RTCP数据包被重新安排在时间tn传输，该时间现在更早了。

- pmembers的值设置为等于members。

​	当大型会话的大多数参与者一次离开但有些人留下时，由于过早的超时，该算法无法防止组大小估计在短时间内错误地降至零。 该算法的确使估计更快地返回到正确值。 这种情况非常罕见，后果也无害，以至于仅将此问题视为次要问题。

### 6.3.5 Timing Out an SSRC

​	偶尔，参与者必须检查其他参与者是否超时。 为此，参与者计算确定的（无随机化因子）接收器的间隔Td，即we_sent为false。自时间tc-MTd（M是超时倍数，默认为5）以来未发送RTP或RTCP数据包的任何其他会话成员都超时。这意味着其SSRC已从成员列表中删除，并且成员已更新。对发件人列表执行类似的检查。 从时间tc-2T（在最后两个RTCP报告间隔内）以来未发送RTP数据包的任何发件人列表都将从发件人列表中删除，并更新了发件人。

​	如果任何成员超时，则应执行第6.3.4节中所述的反向重新考虑算法。

​	参与者必须在每个RTCP传输间隔至少执行一次此检查。

### 6.3.6 传输计时器到期

​	当数据包传输计时器到期时，参与者将执行以下操作：

- 如6.3.1节所述计算传输间隔T，包括随机因子。
- 如果tp + T小于或等于tc，则发送RTCP数据包。 将tp设置为tc，然后按照上一步的方式计算另一个T值，并将tn设置为tc +T。将发送计时器设置为在时间tn再次到期。 如果tp + T大于tc，则将tn设置为tp +T。不发送RTCP数据包。 传输计时器设置为在时间tn到期。
- pmembers 设置为members。

如果发送了RTCP数据包，则将initial的值设置为FALSE。 此外，avg_rtcp_size的值也会更新：

```c++
avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size
```

其中packet_size是刚发送的RTCP数据包的大小。

### 6.3.7 传输BYE数据包

​	当参与者希望离开会话时，将发送BYE数据包以将事件通知其他参与者。 为了避免许多参与者离开系统时BYE数据包泛滥，如果参与者选择离开时成员数大于50，则参与者必须执行以下算法。 该算法取代了成员变量的正常角色，改为对BYE数据包进行计数：

- 当参与者决定离开系统时，tp重置为tc，当前时间，member和pmembers初始化为1，initial设置为1，we_sent设置为false，senders设置为0，而avg_rtcp_size设置为复合BYE数据包的大小。 计算出的间隔T。 然后将BYE数据包调度为时间tn = tc +T。
- 每次接收到来自另一参与者的BYE数据包时，无论该参与者是否存在于成员表中，并且在使用SSRC采样时，无论BYE SSRC是否包括在成员中，成员都会增加1。当接收到其他RTCP数据包或RTP数据包时，成员不增加，而仅对于BYE数据包。同样，avg_rtcp_size仅针对收到的BYE数据包进行更新。RTP数据包到达时，发送方不会更新；它仍然为0。
- 然后，如上所述，BYE数据包的传输遵循传输常规RTCP数据包的规则。

​	这样，可以立即发送BYE数据包，但可以控制其总带宽使用量。 在最坏的情况下，这可能导致RTCP控制数据包使用正常带宽的两倍（10％），对于非BYE RTCP数据包使用5％的带宽，对于BYE则使用5％。

​	不想等待上述机制允许BYE数据包传输的参与者可以离开该组而根本不发送BYE。 该参与者最终将被其他组成员超时。

​	如果参加者决定离开时团体人数估计成员少于50，则参加者可以立即发送BYE数据包。 或者，参与者可以选择执行上述BYE退避算法。

​	无论哪种情况，从未发送过RTP或RTCP数据包的参与者在离开组时都不得发送BYE数据包。

### 6.3.8 更新we_sent

​	如果参与者最近发送了RTP数据包，则变量we_sent包含true，否则包含false。 通过使用与管理发件人表中列出的其他参与者的集合相同的机制来进行此确定。如果参与者在we_sent为false时发送RTP数据包，则它将自身添加到发送方表中，并将we_sent设置为true。 应该执行第6.3.4节中描述的反向重新考虑算法，以可能减少发送SR数据包之前的延迟。每次发送另一个RTP数据包时，该数据包的传输时间都会保留在表中。然后，将正常的发送方超时算法应用于参与者-如果自时间tc-2T开始尚未发送RTP数据包，则参与者将从发送方表中删除自己，减少发送方计数，并将we_sent设置为false。

### 6.3.9 源描述带宽的分配

## 6.4 Sender 和Receiver 报告

​	RTP接收器使用RTCP报告数据包提供接收质量反馈，具体取决于接收器是否也是发送者，可以采用两种形式之一。除了数据包类型代码外，发送方报告（SR）和接收方报告（RR）形式之间的唯一区别是，发送方报告包括一个20字节的发送方信息部分，供活动发送方使用。如果站点自发布上一个报告或上一个报告以来的时间间隔内已发送任何数据包，则发布SR，否则发布RR。

​	SR和RR形式都包括零个或多个接收报告块，对于每个同步源，接收器自上次报告以来已从中接收RTP数据包。未发布有关证监会列表中所列贡献来源的报告。 每个接收报告块提供有关从该块中指示的特定源接收的数据的统计信息。由于SR或RR数据包中最多可以容纳31个接收报告块，因此应根据需要在初始SR或RR数据包之后堆叠其他RR数据包，以包含自上次报告以来该间隔内听到的所有源的接收报告。如果有太多的资源无法将所有必要的RR数据包放入一个复合RTCP数据包中，而又不超过网络路径的MTU，则每个时间间隔应仅包括适合一个MTU的子集。应该在多个时间间隔内循环选择子集，以便报告所有来源。

​	下一节将定义两个报告的格式，如果应用程序需要其他反馈信息，如何以特定于配置文件的方式扩展它们，以及如何使用这些报告。 翻译和混合器的接收报告的详细信息在第7节中给出。

### 6.4.1 SR：发送方报告RTCP数据包

```c++
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=SR=200   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         SSRC of sender                        |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
sender |              NTP timestamp, most significant word             |
info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |             NTP timestamp, least significant word             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         RTP timestamp                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     sender's packet count                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      sender's octet count                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

发件人报告数据包包括三个部分，如果有定义，则可能跟在第四个特定于配置文件的扩展部分之后。 第一部分，标题，长8个八位位组。 这些字段具有以下含义：

version (V): 2 bits 标识RTP的版本，该版本在RTCP数据包中与在RTP数据包中相同。 本规范定义的版本为2。

padding (P): 1. bit

​	如果设置了填充位，则该单独的RTCP数据包在末尾包含一些其他填充八位位组，它们不是控制信息的一部分，而是包含在长度字段中。填充的最后一个八位位组是对应忽略多少个填充八位位组（包括其自身）的计数（它将是四个的倍数）。 一些具有固定块大小的加密算法可能需要填充。在复合RTCP数据包中，只需要在一个单独的数据包上进行填充，因为对于9.1节中的方法，该复合数据包是整体加密的。 因此，只能将填充添加到最后一个单独的数据包，如果将填充添加到该数据包，则必须仅在该数据包上设置填充位。此约定有助于附录A.2中描述的报头有效性检查，并允许检测某些早期实现中的数据包，这些数据包错误地设置了第一个单个数据包的填充位，并向最后一个单个数据包添加了填充。

reception report count (RC): 5 bits 该数据包中包含的接收报告块的数量。 零值是有效的。

packet type (PT): 8 bits 包含常数200，以将其标识为RTCP SR数据包。

length: 16 bits

​	此RTCP数据包的长度（以32位字为单位）减去一，包括标头和任何填充。（偏移量为1会使有效长度为零，并避免了扫描复合RTCP数据包时可能出现的无限循环，而对32位字进行计数则避免了对4的倍数的有效性检查。）

SSRC: 32 bits 此SR数据包始发者的同步源标识符。

第二部分是发送者信息，长度为20个八位位组，并出现在每个发送者报告数据包中。 它总结了来自该发送者的数据传输。 这些字段具有以下含义：

NTP timestamp: 64 bits

​	指示发送该报告时的挂钟时间（请参阅第4节），以便可以与其他接收器的接收报告中返回的时间戳结合使用，以测量到这些接收器的往返传播。 接收者应该期望时间戳的测量精度可能会远远小于NTP时间戳的分辨率。由于可能不知道，因此未指示时间戳的测量不确定性。 在没有挂钟时间概念但有一些特定于系统的时钟的系统上，例如“系统正常运行时间”，发送者可以使用该时钟作为参考来计算相对的NTP时间戳。重要的是选择一个常用的时钟，以便如果使用单独的实现方式来生成多媒体会话的各个流，则所有实现方式都将使用相同的时钟。 直到2036年，相对时间戳和绝对时间戳的高位将有所不同，因此（无效）比较将显示出较大的差异； 到那时，人们希望不再需要相对的时间戳。 没有挂钟或经过时间概念的发送者可以将NTP时间戳设置为零。

RTP timestamp: 32 bits

​	与NTP时间戳相同（上图），但与数据包中的RTP时间戳相同，并且具有相同的随机偏移。 此对应关系可用于其NTP时间戳已同步的源的媒体内和媒体间同步，并且可与媒体无关的接收器用于估计标称RTP时钟频率。请注意，在大多数情况下，此时间戳将不等于任何相邻数据包中的RTP时间戳。 相反，它必须使用RTP时间戳计数器与实时之间的关系从相应的NTP时间戳进行计算，该关系通过在采样时刻定期检查挂钟时间来保持。

sender's packet count: 32 bits

​	从发送开始到生成此SR包为止，发送方发送的RTP数据包的总数。 如果发送方更改其SSRC标识符，则应重置该计数。

sender's octet count: 32 bits

​	自从开始传输直到生成此SR数据包以来，发送方在RTP数据包中传输的有效载荷八比特组总数（即，不包括标头或填充）。 如果发送方更改其SSRC标识符，则应重置该计数。 该字段可用于估计平均有效载荷数据速率。

第三部分包含零个或多个接收报告块，具体取决于自上次报告以来此发送者听到的其他来源的数量。 每个接收报告块传达有关从单个同步源接收RTP数据包的统计信息。 当源由于冲突而更改其SSRC标识符时，接收方不应保留统计信息。 这些统计数据是：

SSRC_n(source identifier): 32 bits 该接收报告块中的信息所属的源的SSRC标识符。

fraction lost: 8 bits

​	自从发送前一个SR或RR数据包以来，来自源SSRC_n的RTP数据包的一部分丢失，表示为定点数，二进制点位于字段的左边缘。（这等效于将损失分数乘以256后取整数部分。）此分数定义为丢失的数据包数除以预期的数据包数，如下一节中定义。附录A.3中显示了一个实现。 如果由于重复造成的损失为负，则将损失的分数设置为零。 请注意，接收器无法判断在最后一个接收到的数据包之后是否丢失了任何数据包，并且如果在最后一次报告间隔内发送的来自该源的所有数据包都丢失了，则不会为该源发出接收报告块。

cumulative number of packets lost: 24 bits (累计丢包数)

​	自接收开始以来，源SSRC_n丢失的RTP数据包总数。 该数目被定义为期望的分组数目减去实际接收的分组数目，其中，所接收的分组数目包括任何迟到或重复的分组。因此，迟到的数据包不算作丢失，如果存在重复，则丢失可能为负。 预期的数据包数量定义为接收到的扩展的最后序列号，如下所定义，减去接收到的初始序列号。 可以按附录A.3所示进行计算。

Extended highest sequence number received: 32 bits (收到的扩展的最高序列号)

​	低16位包含RTP数据包中从源SSRC_n接收到的最高序列号，而最高16位则用相应的序列号周期数扩展该序列号，可以根据附录A.1中的算法进行维护。 请注意，如果同一会话中的不同接收器的开始时间明显不同，它们将生成不同的序列号扩展名。

interarrival jitter: 32 bits (到达间隔抖动)

​	RTP数据包到达时间的统计方差的估计值，以时间戳为单位进行度量，并表示为无符号整数。 到达间隔抖动J被定义为对于一对分组，接收器处的分组间隔与发送者处的分组间隔之差D的平均偏差（平滑的绝对值）。如下式所示，这等于两个数据包的“相对传输时间”之差；相对传输时间是指数据包的RTP时间戳与到达时的接收器时钟之间的差，以相同单位度量。

如果Si是来自数据包i的RTP时间戳，而Ri是以数据包i的RTP时间戳为单位的到达时间，则对于两个数据包i和j，D可表示为

```c++
D(i,j) = (Rj - Ri) - (Sj - Si) = (Rj - Sj) - (Ri - Si)
```

当从源SSRC_n接收到每个数据包i时，应使用公式D到到达顺序（不一定是顺序的）使用该包D和先前包i-1的差D来连续计算到达间隔抖动。 发出报告，对J的当前值进行采样。

抖动计算必须符合此处指定的公式，以允许独立于配置文件的监视器对来自不同实现的报告进行有效的解释。 该算法是最优的一阶估计器，增益参数1/16给出了良好的降噪比，同时保持了合理的收敛速度。附录A.8中显示了示例实现。 参见6.4.4节，以讨论在传输之前改变包的持续时间和延迟的影响。

last SR timestamp (LSR) : 32 bits

​	NTP时间戳（如第4节中所述）中的64位中的32位是从源SSRC_n接收的最新RTCP发送方报告（SR）数据包的一部分。 如果尚未收到SR，则将该字段设置为零。

Delay since last SR (DLSR): 32 bits

​	从源SSRC_n接收最后一个SR数据包到发送此接收报告块之间的延迟，以1/65536秒为单位表示。 如果尚未从SSRC_n接收到SR数据包，则DLSR字段设置为零。

令SSRC_r表示发出此接收器报告的接收器。 源SSRC_n可以通过记录接收到此接收报告块时的时间A，来计算到SSRC_r的往返传播延迟。 它使用最后一个SR时间戳（LSR）字段计算总往返时间A-LSR，然后减去此字段以使往返传播延迟为（A-LSR-DLSR）。这在图2中进行了说明。时间以32位字段的十六进制表示形式和等效的浮点十进制表示形式显示。 冒号表示一个32位字段，分为16位整数部分和16位小数部分。

尽管某些链路具有非常不对称的延迟，但它可以用作到群集接收器的距离的近似度量。

```c++
   [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]
   n                 SR(n)              A=b710:8000 (46864.500 s)
   ---------------------------------------------------------------->
                      v                 ^
   ntp_sec =0xb44db705 v               ^ dlsr=0x0005:4000 (    5.250s)
   ntp_frac=0x20000000  v             ^  lsr =0xb705:2000 (46853.125s)
     (3024992005.125 s)  v           ^
   r                      v         ^ RR(n)
   ---------------------------------------------------------------->
                          |<-DLSR->|
                           (5.250 s)

   A     0xb710:8000 (46864.500 s)
   DLSR -0x0005:4000 (    5.250 s)
   LSR  -0xb705:2000 (46853.125 s)
   -------------------------------
   delay 0x0006:2000 (    6.125 s)
```

​																			图2 往返时间计算示例

### 6.4.2 RR： 接收报告RTCP数据包

```c++
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=RR=201   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     SSRC of packet sender                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

接收者报告（RR）数据包的格式与SR数据包的格式相同，不同之处在于数据包类型字段包含常数201，并且省略了发送方信息的5个字（这是NTP和RTP时间戳以及发送方的数据包和 八位字节计数）。其余字段具有与SR数据包相同的含义。

当没有数据发送或接收要报告时，必须将空的RR数据包（RC = 0）放在复合RTCP数据包的开头。

### 6.4.3 扩展发送方和接收方报告

​	如果有需要定期报告有关发送者或接收者的其他信息，则配置文件应该为发送者报告和接收者报告定义特定于配置文件的扩展。 应优先使用此方法来定义另一种RTCP数据包类型，因为它需要较少的开销：

- 数据包中的八位字节更少（无RTCP头或SSRC字段）；
- 更简单，更快速的解析，因为在该配置文件下运行的应用程序将被编程为始终在接收报告后期望扩展字段位于可直接访问的位置。

该扩展是发送方或接收方报告数据包中的第四部分，该部分在接收报告块（如果有）之后结束。 如果需要其他发送者信息，则对于发送者报告，它将首先包含在扩展部分中，但是对于接收者报告，则将不存在。 如果要包括有关接收机的信息，则该数据应构造成与现有接收报告块阵列平行的块阵列；也就是说，块的数量将由RC字段指示。

### 6.4.4 分析发送方和接收方报告

可以预期，接收质量反馈不仅对发送方有用，而且对其他接收方和第三方监视器也很有用。 发送方可以根据反馈修改其传输； 接收者可以确定问题是本地的，区域的还是全球的； 网络管理员可以使用仅接收RTCP数据包而不接收相应RTP数据包的独立于配置文件的监视器来评估其网络的性能，以进行多播分发。

在发送者信息和接收者报告块中都使用了累计计数，因此可以计算任意两个报告之间的差异，以便在短时间和长时间内进行测量，并提供抵御报告丢失的能力。 最近收到的两个报告之间的差异可用于估计最近的分发质量。 包含NTP时间戳，因此可以根据两次报告之间的时间间隔内的这些差异来计算费率。 由于该时间戳与数据编码的时钟速率无关，因此可以实现与编码和配置文件无关的质量监视器。

一个示例计算是两个接收报告之间的时间间隔内的丢包率。 丢失的累积数据包数量之差给出了在该时间间隔内丢失的数量。 接收到的扩展的最后序列号的差异给出了该间隔内预期的数据包数。 两者的比率是整个时间间隔内的丢包率。如果两个报告是连续的，则此比率应等于损失的分数字段，否则可能不相等。 每秒的丢失率可以通过将丢失分数除以NTP时间戳记的差异（以秒为单位）来获得。 收到的数据包数量是预期的数据包数量减去丢失的数量。例如，5个数据包丢失1个的重要性低于1000个数据包丢失200个。

根据发送方信息，第三方监视器可以在不接收数据的情况下计算一个时间间隔内的平均有效负载数据速率和平均数据包速率。 两者之比得出平均有效载荷大小。 如果可以假设数据包丢失与数据包大小无关，则特定接收器接收到的数据包数乘以平均有效负载大小（或相应的数据包大小）即可得出该接收器可用的视在吞吐量。

除了允许使用报告之间的差异进行长期数据包丢失测量的累计计数之外，“丢失百分比”字段还提供了单个报告的短期测量结果。 随着会话大小的扩大，以至于可能无法为所有接收器保留接收状态信息，或者报告之间的间隔变得足够长，以至于可能仅从特定接收器接收到一个报告，这变得更加重要。

到达间隔抖动字段提供了网络拥塞的第二种短期度量。 丢包跟踪持续的拥塞，而抖动度量跟踪瞬态拥塞。 抖动度量可能表明拥塞，然后才导致丢包。 到达间隔抖动字段仅是报告时抖动的快照，并非旨在定量地获取。 相反，其意图是跨时间比较来自一个接收器的多个报告，或者例如来自同一网络内的多个接收器的多个报告的比较。 为了允许在各个接收器之间进行比较，重要的是，所有接收器均应根据相同的公式来计算抖动。

由于抖动计算是基于RTP时间戳进行的，RTP时间戳表示对数据包中的第一个数据进行采样的时刻，因此该采样时刻与数据包传输时间之间的延迟中的任何变化都会影响所计算出的最终抖动。 对于持续时间变化的音频分组，会发生这种延迟变化。 视频编码也会发生这种情况，因为一帧的所有数据包的时间戳都相同，但是这些数据包并非同时发送。直到传输时的延迟变化确实降低了抖动计算的准确性，而抖动的度量本身就是对网络行为的度量，但是考虑到接收器缓冲区必须容纳该值是适当的。当将抖动计算用作比较措施时，由于直到传输的延迟变化而导致的（恒定）分量会被减去，因此，除非很小，否则可以观察到网络抖动分量的变化。 如果变化很小，则可能无关紧要。

## 6.5 SDES: RTCP包源描述

```c++
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    SC   |  PT=SDES=202  |             length            |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_1                          |
  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_2                          |
  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
```

SDES数据包是由标头和零个或多个块组成的三级结构，每个块由描述该块中标识的源的项组成。 这些项目将在后续章节中单独描述。

version (V), padding (P), length: 在SR包中描述（见6.4.1章节）

packet type (PT): 8 btis, 固定为202 表示RTCP SDES包。

source count (SC): 5 bits, 此SDES包中包含的SSRC/CSRC块的数量，值为0是允许的，但是很少见。

每个块均由一个SSRC / CSRC标识符以及紧随其后的零个或多个项目的列表组成，其中包含有关SSRC / CSRC的信息。 每个块均始于32位边界。 每个项目都包含一个8位类型字段，一个描述文本长度的8位八位字节计数（因此，不包括此两个八位字节的标头）以及文本本身。 请注意，文本的长度不能超过255个八位字节，但这与限制RTCP带宽消耗的需求是一致的。文本根据RFC 2279 [5]中指定的UTF-8编码进行编码。 US-ASCII是此编码的子集，不需要其他编码。 通过将字符的最高有效位设置为值1来指示多字节编码的存在。

items是连续的，即，items没有单独填充到32位边界。 文本不是以空字符结尾的，因为某些多字节的编码包含空字节。 每个组块中的items列表必须以一个或多个空八位字节终止，其中第一个八位字节被解释为零的item类型，以表示列表的末尾。 空项类型的八位字节后面没有长度八位字节，但是如果需要填充，则必须包括其他空八位字节，直到下一个32位边界为止。 请注意，此填充与RTCP标头中的P位指示的填充是分开的。 零items（四个空八位字节）的块是有效的，但没有用。

终端系统发送一个包含其自己的源标识符的SDES数据包（与固定RTP标头中的SSRC相同）。 混合器为每个正在从中接收SDES信息的贡献源发送一个包含块的SDES数据包，或者如果存在超过31个这样的源，则以上述格式发送多个完整SDES数据包。(见7章)

当前定义的SDES项将在下一部分中介绍。 仅CNAME项为必填项。 此处显示的某些项目可能仅对特定配置文件有用，但是所有项目类型都是从一个公共空间分配的，以促进共享使用并简化与配置文件无关的应用程序。 如第15节所述，可以通过向IANA注册类型编号来在配置文件中定义其他项。

### 6.5.1 CNAME

CNAME（Canonical End-Point Identifier SDES Item） 标识符具有以下属性：

- 因为如果发现冲突或重新启动程序，随机分配的SSRC标识符可能会更改，因此必须包含CNAME项，以提供从SSRC标识符到源（发送者或接收者）的标识符的绑定，该绑定保持不变。
- 像SSRC标识符一样，CNAME标识符在一个RTP会话中的所有参与者之间也应该是唯一的。
- 为了提供一个参与者在一组相关的RTP会话中使用的多种媒体工具之间的绑定，应该为该参与者固定CNAME。
- 为了方便第三方监视，CNAME应该适合程序或个人来查找源。

因此，应尽可能通过算法得出CNAME，并且不要手动输入。 为了满足这些要求，除非配置文件指定了其他语法或语义，否则应使用以下格式。CNAME项的格式应为“user@host”，如果用户名在单用户系统上不可用，则应为“host”。对于这两种格式，“host”都是实时数据所源自的主机的全限定域名，其格式按照RFC1034[6],RFC[7]和RFC1123[8]第2.1节中指定的规则进行设置。或用于RTP通信的接口上主机数字地址的标准ASCII表示形式。 例如，IPv4地址的标准ASCII表示形式为“点分十进制”，也称为点分四边形，而对于IPv6，地址以文本形式表示为以冒号分隔的十六进制数字组（如RFC3513[23]中所述）。其他地址类型应具有相互唯一的ASCII表示形式。 完全限定的域名对于人观察者来说更加方便，并且可以避免另外发送NAME项目的需要，但是在某些操作环境中可能很难或不可能可靠地获得。 在这种环境下运行的应用程序应该使用地址的ASCII表示。

对于多用户系统，示例为“ doe@sleepy.example.com”，“ doe@192.0.2.89”或“ doe@2201:056D::112E:144A:1E24”。 在没有用户名的系统上，示例为“ sleepy.example.com”，“ 192.0.2.89”或“ 2201:056D::112E:144A:1E24”。

用户名应采用诸如“finger”或“talk”之类的程序可以使用的形式，即通常是登录名，而不是个人名。 主机名不必与参与者的电子邮件地址中的主机名相同。

如果应用程序允许用户从一个主机生成多个源，则此语法不会为每个源提供唯一的标识符。 这样的应用程序将不得不依靠SSRC进一步标识源，或者该应用程序的配置文件将必须为CNAME标识符指定其他语法。

如果每个应用程序独立创建其CNAME，则生成的CNAME可能与在一组相关RTP会话中的一个参与方的跨多个媒体工具提供绑定所需的CNAME不同。 如果需要跨媒体绑定，则可能需要通过协调工具在外部将每个工具的CNAME配置为相同的值。

应用程序编写者应注意，专用网络地址分配（例如RFC1918 [24]中建议的Net-10分配）可能会创建并非全局唯一的网络地址。 如果具有私有地址且没有到公共Internet的直接IP连接的主机将其RTP数据包通过RTP级别的转换器转发到公共Internet，则将导致非唯一的CNAME。（见RFC1627[25]）。为了处理这种情况，应用程序可以提供一种配置唯一的CNAME的方法，但是如果有必要防止将私有地址暴露出来，那么翻译者就要负担将CNAME从私有地址转换为公共地址的负担。

### 6.5.2 NAME：用户名SDES项

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=2    |     length    | common name of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

这是用来描述来源的真实名称，例如“ John Doe，Bit Recycler”。 它可以是用户期望的任何形式。 对于诸如会议之类的应用程序，这种形式的名称可能是在参与者列表中显示的最理想的方式，因此，除了CNAME之外，其他项目中的发送频率最高。概况可以建立这样的优先级。 至少在会话期间，期望NAME值保持恒定。 在会议的所有参与者中不应依赖它唯一。

### 6.5.3 EMAIL:电子邮件地址SDES项

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3    |     length    | email address of source     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

电子邮件地址是根据RFC2822 [9]格式化的，例如“ John.Doe@example.com”。 预计EMAIL值在会话期间将保持不变。

### 6.5.4 PHONE:电话号码SDES项

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=4    |     length    | phone number of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

电话号码应以加号代替国际接入代码。 例如，在美国，数字为“ +1 908 555 1212”。

### 6.5.5 LOC:地理用户位置SDES项

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=5     |     length    | geographic location of site ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

取决于应用程序，此项目适合不同的细节程度。 对于会议应用程序而言，诸如“新泽西州默里山”的字符串可能就足够了，而对于主动式徽章系统，诸如“ Room 2A244，AT＆T BL MH”之类的字符串可能是合适的。 具体程度由实施者和/或用户决定，但是格式和内容可以由配置文件规定。 除移动主机外，预计LOC值在会话期间将保持恒定。

### 6.5.6 应用程序或工具名称SDES项

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=6    |     length    |name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

一个字符串，提供生成流的应用程序的名称和可能的版本，例如“ videotool 1.2”。 此信息对于调试目的可能有用，并且类似于Mailer或Mail-System-Version SMTP标头。 预期TOOL值在会话期间将保持不变。

### 6.5.7 NOTE: Notice/Status SDES项

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=7    |     length    | note about the source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

建议为该项目提供以下语义，但是这些或其他语义可以由配置文件明确定义。 NOTE项用于描述消息源当前状态的瞬时消息，例如“在电话上，无法通话”。 或者，在研讨会期间，此项目可能用于传达演讲的标题。 它仅应用于携带特殊信息，并且不应被所有参与者常规包括在内，因为这会减慢接收报告和CNAME的发送速度，从而损害协议的性能。 特别是，不应将其作为项目包含在用户的配置文件中，也不应像在报价单中那样自动生成。

**由于NOTE项在激活时可能对显示很重要**，因此可能会降低传输其他非CNAME项（如NAME）的速率，以便NOTE项可以占用RTCP带宽的那部分。 当瞬态消息变为非活动状态时，应继续以相同的重复率几次发送NOTE项，但其长度为零，以信号通知接收方。 但是，如果在重复率的小数倍或20-30个RTCP间隔内未收到NOTE项目，则接收方也应将其视为非活动状态。

### 6.5.8 PRIV: 专用扩展SDES项

```c++
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     PRIV=8    |     length    | prefix length |prefix string...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...             |                  value string               ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

此项用于定义实验性或特定于应用程序的SDES扩展。 该项目包含一个由长度字符串对组成的前缀，后跟填充该项目其余部分并携带所需信息的值字符串。 前缀长度字段为8位长。 前缀字符串是由定义PRIV项的人选择的名称，该名称相对于此应用程序可能收到的其他PRIV项是唯一的。如果需要，应用程序创建者可以选择使用应用程序名称以及其他子类型标识。 另外，建议其他人根据他们代表的实体选择一个名称，然后在该实体内协调名称的使用。

请注意，前缀在项目的255个八位字节的总长度内消耗了一些空间，因此，前缀应保持尽可能短。 该功能和受约束的RTCP带宽不应过载； 它并非旨在满足所有应用程序的所有控制通信要求。

IDES将不会注册SDES PRIV前缀。 如果某种形式的PRIV项被证明具有通用性，则应该向其分配在IANA中注册的常规SDES项类型，因此不需要前缀。 这简化了使用并提高了传输效率。

## 6.6 BYE：Goodbye RTCP Packet

```c++
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |V=2|P|    SC   |   PT=BYE=203  |             length            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           SSRC/CSRC                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                              ...                              :
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
(opt) |     length    |               reason for leaving            ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

BYE数据包指示一个或多个源不再处于活动状态。

version (V), padding (P), length: 如SR包所述（参见6.4.1节）

Packet type (PT): 8 bits, 使用203来表示

source count (SC): 5 bits, 表示数据包中的SSRC/CSRC标识符的数量。值为0是有效的，但没有用。

第6.3.7节和第8.2节中规定了何时发送BYE数据包的规则。

如果混合器接收到BYE数据包，则混合器应转发SSRC / CSRC标识符不变的BYE数据包。 如果混合器关闭，它应该发送一个BYE数据包，列出它处理的所有贡献源以及它自己的SSRC标识符。 可选地，BYE数据包可以包含一个8位八位字节计数，后跟指示退出原因的文本的许多八位字节，例如“摄像机故障”或“检测到RTP循环”。 该字符串与SDES所描述的编码相同。 如果字符串将数据包填充到下一个32位边界，则该字符串不是以null结尾的。 如果不是，则BYE包必须用空八位字节填充到下一个32位边界。 此填充与RTCP标头中的P位指示的填充是分开的。

## 6.7 APP：应用定义的RTCP包

```c++
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P| subtype |   PT=APP=204  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          name (ASCII)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   application-dependent data                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

APP数据包打算用于实验用途，因为它需要开发新的应用程序和新功能，而无需注册数据包类型值。 应忽略名称不明的APP数据包。经过测试并证明有更广泛的用途时，建议重新定义每个APP数据包，而不包含子类型和名称字段，并使用RTCP数据包类型向IANA注册。

。。。。

# 7 RTP 转换器和混音器

除了终端系统之外，RTP还支持“翻译器”和“混合器”的概念，它们在RTP级别上可以被视为“中间系统”。 尽管这种支持使协议增加了一些复杂性，但是通过Internet上的多播音频和视频应用程序的实验已经清楚地确定了对这些功能的需求。 第2.3节中给出的转换器和混合器的示例用法是由于存在防火墙和低带宽连接而导致的，这两种情况都可能会保留下来。

。。。。。

# 8 SSRC标识符分配和使用

​	RTP报头和RTCP数据包的各个字段中携带的SSRC标识符是32位随机数，在RTP会话中必须是全局唯一的。至关重要的是，请谨慎选择号码，以使同一网络或同一时间开始的参与者不太可能选择相同的号码。

​	仅使用本地网络地址（例如IPv4地址）作为标识符是不够的，因为该地址可能不是唯一的。 由于RTP转换器和混合器允许在具有不同地址空间的多个网络之间进行互操作，因此两个空间内地址的分配模式可能导致比随机分配高得多的冲突率。一台主机上运行的多个源也将发生冲突。仅通过调用random()而不仔细初始化状态来获得SSRC标识符也是不够的。 附录A.6中提供了如何生成随机标识符的示例。

## 8.1 碰撞概率

​	由于标识符是随机选择的，因此可能会出现两个以上选择了相同的数字。当同时启动所有源时（eg，由某个会话管理事件自动触发时），冲突发生的可能性最高。如果N是源数量，L是标识符长度（此处为32位），则对于大于N[26]，两个源独立选择相同值的概率可以近似为1-exp(-N**2/2**(L+1))。对于N=1000，概率大约为10**-4。

​	典型的碰撞概率远低于上述最坏情况。当一个新的源加入一个RTP会话（其中所有其他源都已经具有唯一的标识符）时，发生冲突的可能性只是空间中使用的数字的一部分。同样，如果N是源的数量，而L是标识符的长度，则发生碰撞的概率为N / 2 ** L。 对于N = 1000，概率大约为2 * 10 **-7。

​	新源在发送第一个数据包（数据或控制数据）之前有机会从其他参与者接收数据包，从而进一步降低了冲突的可能性。如果新源跟踪其他参与者（通过SSRC标识符），则在发送其第一个数据包之前，新源可以验证其标识符是否与已接收的任何标识符不冲突，否则请再次选择。

## 8.2 冲突解决和循环检测

​	尽管SSRC标识符冲突的可能性很小，但是所有RTP实现都必须准备检测冲突并采取适当的措施来解决它们。如果一个源在任何时候发现另一个源正在使用与其自身相同的SSRC标识符，则它必须为旧的标识符发送一个RTCP BYE数据包，并选择另一个随机的。（如下所述，在循环的情况下，此步骤仅执行一次。）如果接收方发现其他两个源发生冲突，则当可以通过不同的源传输地址或CNAME检测到它时，可以保留一个源的数据包，并丢弃另一个源的数据包。 预计这两个消息源将解决冲突，以便这种情况不会持续下去。

​	由于随机SSRC标识符对于每个RTP会话在全局上保持唯一，因此它们也可以用于检测可能由混频器或转换器引入的环路。循环会导致数据和控制信息重复，这些数据或控制信息未经修改或可能混合在一起，如以下示例所示：

- 转换程序可能会直接或通过一系列转换程序错误地将数据包转发到从其接收数据包的同一多播组。 在这种情况下，同一数据包会出现几次，源自不同的网络来源。
- 错误地并行设置的两个转换器（即，两端都具有相同的多播组）会同时将数据包从一个多播组转发到另一个。 单向翻译器将产生两份副本； 双向转换器会形成一个循环。
- 混合器可以直接或通过另一个混合器或转换器发送到接收数据包的相同传输目的地，从而关闭环路。 在这种情况下，源可能同时显示为数据包上的SSRC和混合数据包中的CSRC。

​	一个源可能发现自己的数据包正在循环，或者发现来自另一个源的数据包正在循环（第三方循环）。 源标识符的随机选择中的循环和冲突都会导致数据包以相同的SSRC标识符到达，但源传输地址不同，这可能是发起该数据包的最终系统或中间系统的地址。因此，如果一个源改变了它的源传输地址，它也可以选择一个新的SSRC标识符以避免被解释为一个循环的源。 （这不是必须的，因为在某些RTP应用程序中，可能希望在会话期间更改源地址。）请注意，如果转换器重新启动并因此更改了其转发数据包的源传输地址（例如，更改了UDP源端口号），则所有这些数据包都会在接收方看来是循环的，因为SSRC标识符是由原始源应用的 并且不会改变。可以通过在重新启动之间保持源传输地址固定来避免此问题，但是无论如何在接收方超时后都可以解决。

如果数据包的所有副本都通过转换器或混合器，则无法使用源传输地址检测在转换器或混合器远端发生的循环或冲突，但是，当来自两个RTCP SDES数据包的数据块包含 相同的SSRC标识符，但CNAME不同。

为了检测和解决这些冲突，RTP实现必须包括一种与以下所述算法类似的算法，尽管该实现可以选择一种策略来保留来自冲突第三方的数据包。 下述算法将忽略来自新来源或与已建立来源冲突的环路的数据包。 它通过发送用于旧标识符的RTCP BYE并选择一个新标识符来解决与参与者自己的SSRC标识符的冲突。 但是，当冲突是由参与者自己的数据包循环引起的时，算法将仅选择一次新标识符，然后从循环源传输地址中忽略数据包。 这是避免泛滥BYE数据包所必需的。

该算法需要保持一个由源标识符索引的表，并包含来自该标识符接收的第一个RTP数据包和第一个RTCP数据包的源传输地址，以及该源的其他状态。 由于例如，RTP和RTCP数据包上的UDP源端口号可能不同，因此需要两个源传输地址。 但是，可以假定两个源传输地址中的网络地址相同。

在源标识符表中查找在RTP或RTCP数据包中接收到的每个SSRC或CSRC标识符，以便处理该数据或控制信息。 将数据包中的源传输地址与表中相应的源传输地址进行比较，以检测是否存在循环或冲突。 对于控制包，每个具有自己的SSRC标识符的元素（例如SDES块）都需要单独的查找。（接收报告块中的SSRC标识符是一个例外，因为它标识了报告者听到的源，并且该SSRC标识符与报告者发送的RTCP数据包的源传输地址无关。）如果不是SSRC或CSRC 找到后，将创建一个新条目。 当接收到带有相应SSRC标识符的RTCP BYE数据包并通过匹配的源传输地址进行验证时，或者在较长时间内没有任何数据包到达之后，这些表条目将被删除（请参阅第6.2.1节）。

请注意，如果在接收方开始操作时同一主机上的两个源正在使用相同的源标识符进行传输，则接收到的第一个RTP数据包可能来自一个源，而接收到的第一个RTCP数据包则来自另一个源。 。 这将导致错误的RTCP信息与RTP数据相关联，但是这种情况应足够少见且无害，以至可以忽略。

为了跟踪参与者自己的数据包的循环，实现还必须保留发现已冲突的源传输地址（而不是标识符）的单独列表。 如在源标识符表中一样，必须保留两个源传输地址以分别跟踪冲突的RTP和RTCP数据包。请注意，冲突的地址列表应简短，通常为空。 此列表中的每个元素都存储源地址以及接收到最近冲突的数据包的时间。 当有冲突的数据包在10个RTCP报告间隔的时间内没有从那个源到达时，可以从列表中删除一个元素（见6.2节）。

对于所示算法，假定参与者自己的源标识符和状态包含在源标识符表中。 可以对算法进行重组，使其首先与参与者自己的源标识符进行单独的比较。

```c++
if (SSRC or CSRC identifier is not found in the source identifier table) {
          create a new entry storing the data or control source
              transport address, the SSRC or CSRC and other state;
}
/* Identifier is found in the table */
else if (table entry was created on receipt of a control packet and this is the first data packet or vice versa) {
  store the source transport address from this packet;
}
else if (source transport address from the packet does not match the one saved in the table entry for this identifier) {
  /* An identifier collision or a loop is indicated */
  if (source identifier is not the participant's own) {
      /* OPTIONAL error counter step */
      if (source identifier is from an RTCP SDES chunk
          containing a CNAME item that differs from the CNAME
          in the table entry) {
        count a third-party collision;
      } else {
        count a third-party loop;
      }
      abort processing of data packet or control element;
      /* MAY choose a different policy to keep new source */
      }
      /* A collision or loop of the participant's own packets */
      else if (source transport address is found in the list of
               conflicting data or control source transport
               addresses) {
        /* OPTIONAL error counter step */
        if (source identifier is not from an RTCP SDES chunk
            containing a CNAME item or CNAME is the
            participant's own) {
            count occurrence of own traffic looped;
            }
            mark current time in conflicting address list entry;
            abort processing of data packet or control element;
            }
          /* New collision, change SSRC identifier */
          else {
              log occurrence of a collision;
              create a new entry in the conflicting data or control
                  source transport address list and mark current time;
              send an RTCP BYE packet with the old SSRC identifier;
              choose a new SSRC identifier;
              create a new entry in the source identifier table with
                  the old SSRC plus the source transport address from
                  the data or control packet being processed;
          }
      }
```

在此算法中，来自新冲突源地址的数据包将被忽略，并将保留来自原始源地址的数据包。 如果在较长时间内没有数据包从原始源到达，则表条目将超时并且新源将能够接管。 如果原始源检测到冲突并移动到新的源标识符，则可能会发生这种情况，但是在通常情况下，将从原始源接收RTCP BYE数据包以删除状态，而不必等待超时。

如果原始源地址是通过混频器接收的（即作为CSRC学习的），后来又直接接收到相同的源地址，则可能会建议接收者切换到新的源地址，除非混合中的其他源地址会丢失。 此外，对于诸如电话之类的应用，其中某些源（如移动实体）可能会在RTP会话过程中更改地址，RTP实现应修改冲突检测算法以接受来自新源传输地址的数据包。 为了防止在确实发生冲突的情况下地址之间的翻转，算法应该包括一些检测这种情况并避免切换的方法。

当由于冲突而选择新的SSRC标识符时，应首先在源标识符表中查找候选标识符，以查看其是否已被其他源使用。 如果是这样，则必须生成另一个候选者并重复该过程。

到多播目标的数据包循环可能导致严重的网络泛洪。 所有混合器和翻译器都必须实现一种类似于此处的循环检测算法，以便它们可以中断循环，这应将多余的流量限制为不超过原始流量的一个重复副本，这可以允许会话继续进行，从而 可以找到并修复此循环。 但是，在极端情况下，混频器或转换器无法正确中断环路，从而导致高流量水平，终端系统可能有必要完全停止传输数据或控制数据包。 该决定可能取决于应用程序。 应适当指出一个错误情况。 经过很长的随机时间（以分钟为单位）后，可以周期性地尝试再次发送。

## 8.3 与分层编码一起使用

对于在单独的RTP会话上传输的分层编码（请参见第2.4节），应在所有层的会话之间使用单个SSRC标识符空间，而应将核心（基础）层用于SSRC标识符分配和冲突解决。 当源发现其已发生冲突时，它仅在基础层上发送RTCP BYE数据包，但在所有层中将SSRC标识符更改为新值。

# 11 网络和传输协议上的RTP

本节描述特定于在特定网络和传输协议中承载RTP数据包的问题。 除非被本规范之外的协议特定的定义所取代，否则以下规则适用。

RTP依赖基础协议来提供RTP数据和RTCP控制流的解复用。对于UDP和类似的协议，RTP应该使用偶数目的端口号，而相应的RTCP流应该使用下一个更高（奇数）目的端口号。对于使用单个端口号作为参数并从该端口号导出RTP和RTCP端口对的应用程序，如果提供了奇数，则应用程序应将该端口号替换为下一个较低的（偶数）号，以用作该端口号的基数。 端口对。对于通过显式的，单独的参数（使用信令协议或其他方式）指定RTP和RTCP目标端口号的应用程序，尽管使用偶数，应用程序可以忽略端口号为偶数/奇数和连续的限制。 仍然鼓励使用/ odd端口对。RTP和RTCP端口号一定不能相同，因为RTP依赖端口号来解复用RTP数据和RTCP控制流。

在单播会话中，两个参与者都需要标识用于接收RTP和RTCP数据包的端口对。 双方都可以使用相同的端口对。 参与者不得假定传入的RTP或RTCP数据包的源端口可用作传出的RTP或RTCP数据包的目标端口。当双向发送RTP数据包时，每个参加者的RTCP SR包必须发送到另一参加者指定用于接收RTCP的端口。RTCP SR数据包将传出数据的发送者信息与传入数据的接收报告信息结合在一起。 如果一方没有主动发送数据（请参见第6.4节），则发送RTCP RR数据包。

建议分层编码应用程序（请参见第2.4节）使用一组连续的端口号。 端口号必须不同，因为现有操作系统中普遍存在缺陷，无法使用同一端口使用多个多播地址，而对于单播，只有一个允许的地址。因此，对于第n层，数据端口为P + 2n，控制端口为P + 2n +1。使用IP多播时，地址也必须是不同的，因为多播路由和组成员资格是根据地址粒度进行管理的。但是，由于某些组可能需要不同的范围，因此可能会从不同的地址范围进行分配，因此无法假定分配了连续的IP多播地址。

上一段与SDP规范RFC 2327[15]相冲突，该规范说，在同一会话描述中同时指定多个地址和多个端口是非法的，因为地址与端口的关联可能不明确。旨在在RFC2327的修订版中放宽此限制，以允许使用暗示的一对一映射来指定相等数量的地址和端口。

RTP数据包不包含长度字段或其他描述，因此RTP依赖于基础协议来提供长度指示。 RTP数据包的最大长度仅受基础协议限制。

如果要在提供连续八位字节流而不是消息（数据包）抽象的基础协议中承载RTP数据包，则必须定义RTP数据包的封装以提供成帧机制。 如果基础协议可能包含填充，则也需要成帧，从而无法确定RTP有效负载的范围。 此处未定义成帧机制。

一个配置文件可以指定一种成帧方法，即使在提供成帧的协议中携带RTP时也可以使用，以便允许在一个较低层协议数据单元中携带多个RTP包，例如UDP包。 在一个网络中传输几个RTP数据包或传输数据包可减少报头开销，并可简化不同流之间的同步。

# 12 协议常量摘要

本节包含本规范中定义的常量的摘要列表。

RTP有效负载类型(PT)常量在配置文件中定义，而不是在本文档中定义。

但是，包含标记位和有效载荷类型的RTP头的八位字节必须避免保留值200和201（十进制），以区分RTP数据包与RTCP SR和RR数据包类型，以进行附录中所述的头验证程序 A.1。对于本规范中所示的一个标记位和一个7位有效载荷类型字段的标准定义，此限制意味着保留有效载荷类型72和73。

## 12.1 RTCP数据包类型

```c++
   abbrev.  name                 value
   SR       sender report          200
   RR       receiver report        201
   SDES     source description     202
   BYE      goodbye                203
   APP      application-defined    204
```

与RTP数据包或其他无关数据包相比，可以在200-204范围内选择这些类型值，以提高RTCP数据包的报头有效性检查。将RTCP数据包类型字段与RTP报头的相应八位位组进行比较时，此范围对应于标记位为1（通常不在数据包中）和标准有效负载类型字段的高位为1（ 因为静态有效负载类型通常在下半部分定义）。由于全零和全一是常见的数据模式，因此该范围也选择为从0到255的数值距离。

由于所有复合RTCP数据包都必须以SR或RR开头，因此将这些代码选择为偶数/奇数对，以允许RTCP有效性检查以使用掩码和值测试最大位数。可以通过IANA注册其他RTCP数据包类型（请参阅第15节）。

## 12.2 SDES 类型

```c++
   abbrev.  name                            value
   END      end of SDES list                    0
   CNAME    canonical name                      1
   NAME     user name                           2
   EMAIL    user's electronic mail address      3
   PHONE    user's phone number                 4
   LOC      geographic user location            5
   TOOL     name of application or tool         6
   NOTE     notice about the source             7
   PRIV     private extensions                  8
```

可以通过IANA注册其他SDES类型（请参阅第15节）。

# 附录A-演算法

我们为RTP发送方和接收方算法的各个方面提供了C代码示例。 可能存在其他在特定操作环境中更快的实施方法或具有其他优点。 这些实施说明仅供参考，旨在阐明RTP规范。

以下定义用于所有示例； 为了清楚和简洁起见，结构定义仅对32位big-endian（最高有效字节优先）架构有效。 假定位字段按大端优先位顺序紧密打包，没有其他填充。 需要进行修改以构造可移植的实现。

```c
   /*
    * rtp.h  --  RTP header file
    */
   #include <sys/types.h>

   /*
    * The type definitions below are valid for 32-bit architectures and
    * may have to be adjusted for 16- or 64-bit architectures.
    */
   typedef unsigned char  u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int   u_int32;
   typedef          short int16;

   /*
    * Current protocol version.
    */
   #define RTP_VERSION    2

   #define RTP_SEQ_MOD (1<<16)
   #define RTP_MAX_SDES 255      /* maximum text length for SDES */

   typedef enum {
       RTCP_SR   = 200,
       RTCP_RR   = 201,
       RTCP_SDES = 202,
       RTCP_BYE  = 203,
       RTCP_APP  = 204
   } rtcp_type_t;

   typedef enum {
       RTCP_SDES_END   = 0,
       RTCP_SDES_CNAME = 1,
       RTCP_SDES_NAME  = 2,
       RTCP_SDES_EMAIL = 3,
       RTCP_SDES_PHONE = 4,
       RTCP_SDES_LOC   = 5,
       RTCP_SDES_TOOL  = 6,
       RTCP_SDES_NOTE  = 7,
       RTCP_SDES_PRIV  = 8
   } rtcp_sdes_type_t;
   /*
    * RTP data header
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int x:1;         /* header extension flag */
       unsigned int cc:4;        /* CSRC count */
       unsigned int m:1;         /* marker bit */
       unsigned int pt:7;        /* payload type */
       unsigned int seq:16;      /* sequence number */
       u_int32 ts;               /* timestamp */
       u_int32 ssrc;             /* synchronization source */
       u_int32 csrc[1];          /* optional CSRC list */
   } rtp_hdr_t;
   /*
    * RTCP common header word
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int count:5;     /* varies by packet type */
       unsigned int pt:8;        /* RTCP packet type */
       u_int16 length;           /* pkt len in words, w/o this word */
   } rtcp_common_t;
   /*
    * Big-endian mask for version, padding bit and packet type pair
    */
   #define RTCP_VALID_MASK (0xc000 | 0x2000 | 0xfe)
   #define RTCP_VALID_VALUE ((RTP_VERSION << 14) | RTCP_SR)

   /*
    * Reception report block
    */
   typedef struct {
       u_int32 ssrc;             /* data source being reported */
       unsigned int fraction:8;  /* fraction lost since last SR/RR */
       int lost:24;              /* cumul. no. pkts lost (signed!) */
       u_int32 last_seq;         /* extended last seq. no. received */
       u_int32 jitter;           /* interarrival jitter */
       u_int32 lsr;              /* last SR packet from this source */
       u_int32 dlsr;             /* delay since last SR packet */
   } rtcp_rr_t;
   /*
    * SDES item
    */
   typedef struct {
       u_int8 type;              /* type of item (rtcp_sdes_type_t) */
       u_int8 length;            /* length of item (in octets) */
       char data[1];             /* text, not null-terminated */
   } rtcp_sdes_item_t;
   /*
    * One RTCP packet
    */
   typedef struct {
       rtcp_common_t common;     /* common header */
       union {
           /* sender report (SR) */
           struct {
               u_int32 ssrc;     /* sender generating this report */
               u_int32 ntp_sec;  /* NTP timestamp */
               u_int32 ntp_frac;
               u_int32 rtp_ts;   /* RTP timestamp */
               u_int32 psent;    /* packets sent */
               u_int32 osent;    /* octets sent */
               rtcp_rr_t rr[1];  /* variable-length list */
           } sr;

           /* reception report (RR) */
           struct {
               u_int32 ssrc;     /* receiver generating this report */
               rtcp_rr_t rr[1];  /* variable-length list */
           } rr;

           /* source description (SDES) */
           struct rtcp_sdes {
               u_int32 src;      /* first SSRC/CSRC */
               rtcp_sdes_item_t item[1]; /* list of SDES items */
           } sdes;

           /* BYE */
           struct {
               u_int32 src[1];   /* list of sources */
               /* can't express trailing text for reason */
           } bye;
       } r;
   } rtcp_t;
   typedef struct rtcp_sdes rtcp_sdes_t;

   /*
    * Per-source state information
    */
   typedef struct {
       u_int16 max_seq;        /* highest seq. number seen */
       u_int32 cycles;         /* shifted count of seq. number cycles */
       u_int32 base_seq;       /* base seq number */
       u_int32 bad_seq;        /* last 'bad' seq number + 1 */
       u_int32 probation;      /* sequ. packets till source is valid */
       u_int32 received;       /* packets received */
       u_int32 expected_prior; /* packet expected at last interval */
       u_int32 received_prior; /* packet received at last interval */
       u_int32 transit;        /* relative trans time for prev pkt */
       u_int32 jitter;         /* estimated jitter */
       /* ... */
   } source;
```

## A.1 RTP数据头有效性检查

RTP接收器应检查传入数据包上的RTP标头的有效性，因为它们可能是加密的，或者可能来自其他应用程序，而该应用程序恰好地址错误。类似地，如果启用了根据第9节中所述方法进行的加密，则尽管报头有效性检查失败（例如，未知有效负载类型）可能不一定表明报头有效性检查，以验证输入的数据包已被正确解密， 解密失败。

对来自之前从未听过的源的RTP数据包仅进行弱有效性检查：

- RTP版本字段必须等于2.
- 有效负载类型必须是已知的，尤其是不得等于SR或RR。
- 如果设置了P位，则数据包的最后一个八位位组必须包含一个有效的八位位组计数，尤其是小于总包长减去报头大小。
- 如果配置文件未制定可以使用标头扩展机制，则X位必须为0.否则，扩展长度字段必须小于总包大小减去固定报头长度和填充。
- 数据包的长度必须与CC和有效负载类型一致（如果有效负载具有已知长度）。

后三项检查有些复杂，并非总是可能的，只剩下前两项检查，总共只有几位。如果数据包中的SSRC标识符是之前已收到的，则该数据包可能有效，并且检查序列号是否在预期范围内可提供进一步的验证。如果以前没有看到过SSRC标识符，则携带该标识符的数据包可以被认为是无效的，直到它们中的少数带有连续序列号到达为止。如果产生的延迟是可以接受的，则那些无效的数据包可以被丢弃，或者可以在验证完成后被存储和交付。

下面显示的例程update_seq确保仅在依次接收到MIN_SEQUENTIAL数据包之后，才声明源有效。 它还验证新接收到的数据包的序列号seq并更新s指向的结构中数据包源的序列状态。

当第一次听到一个新的源时，也就是说，它的SSRC标识符不在表中（请参见第8.2节），并且为每个源分配了状态，将s-> probation设置为顺序数 声明源有效（参数MIN_SEQUENTIAL）之前需要的数据包和其他变量已初始化：

```C
init_seq(s, seq);
      s->max_seq = seq - 1;
      s->probation = MIN_SEQUENTIAL;
```

一个非零的s-> probation将源标记为无效，因此状态可能会在短暂的超时后而不是较长的超时后被丢弃，如第6.2.1节中所述。

在一个源被视为有效之后，如果序列号不超过s-> max_seq之前的MAX_DROPOUT或后面不超过MAX_MISORDER，则该序列号被视为有效。 如果新序列号在RTP序列号范围（16位）的模上超出max_seq，但小于max_seq，则它已缠绕并且序列号周期的（移位的）计数增加。 返回值1表示有效的序列号。

否则，返回值零以指示验证失败，并存储错误的序列号加1。 如果接收到的下一个数据包带有下一个更高的序列号，则认为该新数据包序列的有效开始可能是由扩展丢失或源重新启动引起的。 由于可能已经错过了多个完整的序列号循环，因此将重置丢包统计信息。

根据最大错序时间为2秒（50个数据包/秒）和最大丢失时间为1分钟，显示了参数的典型值。 丢弃参数MAX_DROPOUT应该占16位序列号空间的一小部分，以给出合理的可能性，即重启后新的序列号不会落在重启之前的序列号可接受的范围内。

```c
   void init_seq(source *s, u_int16 seq)
   {
       s->base_seq = seq;
       s->max_seq = seq;
       s->bad_seq = RTP_SEQ_MOD + 1;   /* so seq == bad_seq is false */
       s->cycles = 0;
       s->received = 0;
       s->received_prior = 0;
       s->expected_prior = 0;
       /* other initialization */
   }

   int update_seq(source *s, u_int16 seq)
   {
       u_int16 udelta = seq - s->max_seq;
       const int MAX_DROPOUT = 3000;
       const int MAX_MISORDER = 100;
       const int MIN_SEQUENTIAL = 2;

       /*
        * Source is not valid until MIN_SEQUENTIAL packets with
        * sequential sequence numbers have been received.
        */
       if (s->probation) {
           /* packet is in sequence */
           if (seq == s->max_seq + 1) {
               s->probation--;
               s->max_seq = seq;
               if (s->probation == 0) {
                   init_seq(s, seq);
                   s->received++;
                   return 1;
               }
           } else {
               s->probation = MIN_SEQUENTIAL - 1;
               s->max_seq = seq;
           }
           return 0;
       } else if (udelta < MAX_DROPOUT) {
           /* in order, with permissible gap */
           if (seq < s->max_seq) {
               /*
                * Sequence number wrapped - count another 64K cycle.
                */
               s->cycles += RTP_SEQ_MOD;
           }
           s->max_seq = seq;
       } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {
           /* the sequence number made a very large jump */
           if (seq == s->bad_seq) {
               /*
                * Two sequential packets -- assume that the other side
                * restarted without telling us so just re-sync
                * (i.e., pretend this was the first packet).
                */
               init_seq(s, seq);
           }
           else {
               s->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);
               return 0;
           }
       } else {
           /* duplicate or reordered packet */
       }
       s->received++;
       return 1;
   }
```

可以使有效性检查更强，依次需要两个以上的数据包。 缺点是大量初始数据包将被丢弃（或在队列中延迟），并且较高的数据包丢失率可能会阻止验证。但是，由于RTCP报头验证相对较强，因此，如果在数据包之前先从源接收到RTCP包，则可以调整计数，以便依次只需要两个包。如果可以忍受几秒钟的初始数据丢失，则应用程序可以选择丢弃来自某个源的所有数据包，直到从该源接收到有效的RTCP包为止。

取决于应用程序和编码，算法可能会利用有关有效负载格式的其他知识来进行进一步验证。 对于所有分组的时间戳增量都相同的有效载荷类型，可以使用序列号差（假设有效载荷类型没有变化）根据从同一源接收的前一个分组来预测时间戳值。

强大的“快速路径”检查是可能的，因为新序列中接收到的RTP数据包的报头中的前四个八位位组与来自同一SSRC的前一个数据包的前四位八位组的可能性非常高，只是序列号具有 增加了一个。 同样，单项缓存可用于通常一次从一个源接收数据的应用程序中更快的SSRC查找。

## A.2 RTCP头有效性检查

以下检查应应用于RTCP数据包。

- RTP版本字段必须等于2。
- 复合数据包中第一个RTCP数据包的有效负载类型字段必须等于SR或RR。
- 对于复合RTCP数据包的第一个数据包，填充位（P）应该为零，因为仅在需要时才应对最后一个数据包应用填充。
- 各个RTCP数据包的长度字段必须总计为接收到的复合RTCP数据包的总长度。 这是一个相当强大的检查。

下面的代码片段执行所有这些检查。 由于可能存在未知的数据包类型，因此不检查该数据包类型是否包含后续数据包，因此应将其忽略。

```c
      u_int32 len;        /* length of compound RTCP packet in words */
      rtcp_t *r;          /* RTCP header */
      rtcp_t *end;        /* end of compound RTCP packet */

      if ((*(u_int16 *)r & RTCP_VALID_MASK) != RTCP_VALID_VALUE) {
          /* something wrong with packet format */
      }
      end = (rtcp_t *)((u_int32 *)r + len);

      do r = (rtcp_t *)((u_int32 *)r + r->common.length + 1);
      while (r < end && r->common.version == 2);
      if (r != end) {
          /* something wrong with packet format */
      }
```

## A.3 确定预期和丢失的数据包数量

为了计算丢包率，需要使用通过以下代码中的指针s引用的结构源中定义的每个源状态信息，知道从每个源实际预期接收到的RTP数据包的数量。接收到的数据包数量只是到达时的数据包计数，包括任何延迟或重复的数据包。 接收机可以将期望的数据包数量计算为接收到的最高序列号（s-> max_seq）与接收到的第一个序列号（s-> base_seq）之差。由于序列号只有16位并且会回绕，因此有必要使用序列号回绕（移位）计数（s->cycles）来扩展最高的序列号。 接收到的数据包计数和周期计数都在附录A.1中保留了RTP报头有效性检查例程。

```c
      extended_max = s->cycles + s->max_seq;
      expected = extended_max - s->base_seq + 1;
```

丢失的数据包数量定义为预期的数据包数量减去实际接收的数据包数量：

```c
lost = expected - s->received;
```

由于此有符号数是24位携带的，因此对于正向损耗，应将其钳位为0x7fffff；对于负向损耗，应将其钳位为0x800000，而不是回绕。

从上一个报告间隔（因为发送了先前的SR或RR数据包）以来丢失的数据包的比例是根据该间隔内预期和接收到的数据包计数的差异计算得出的，其中Expected_prior和Received_prior是上一次接收报告被保存时保存的值。 产生：

```c
      expected_interval = expected - s->expected_prior;
      s->expected_prior = expected;
      received_interval = s->received - s->received_prior;
      s->received_prior = s->received;
      lost_interval = expected_interval - received_interval;
      if (expected_interval == 0 || lost_interval <= 0) fraction = 0;
      else fraction = (lost_interval << 8) / expected_interval;
```

结果分数是一个8位定点数，二进制点在左边缘

## A.4 生成RTCP SDES数据包

此函数将一个SDES块构建到缓冲区b中，该缓冲区b由以数组类型，值和长度提供的argc项组成。 它返回一个指向b中下一个可用位置的指针。

```c
   char *rtp_write_sdes(char *b, u_int32 src, int argc,
                        rtcp_sdes_type_t type[], char *value[],
                        int length[])
   {
       rtcp_sdes_t *s = (rtcp_sdes_t *)b;
       rtcp_sdes_item_t *rsp;
       int i;
       int len;
       int pad;

       /* SSRC header */
       s->src = src;
       rsp = &s->item[0];

       /* SDES items */
       for (i = 0; i < argc; i++) {
           rsp->type = type[i];
           len = length[i];
           if (len > RTP_MAX_SDES) {
               /* invalid length, may want to take other action */
               len = RTP_MAX_SDES;
           }
           rsp->length = len;
           memcpy(rsp->data, value[i], len);
           rsp = (rtcp_sdes_item_t *)&rsp->data[len];
       }

       /* terminate with end marker and pad to next 4-octet boundary */
       len = ((char *) rsp) - b;
       pad = 4 - (len & 0x3);
       b = (char *) rsp;
       while (pad--) *b++ = RTCP_SDES_END;

       return b;
   }
```

## A.5 解析RTCP SDES数据包

该函数解析一个SDES数据包，调用函数find_member()以查找指向给定SSRC标识符的会话成员信息的指针，并调用member_sdes（）存储该成员的新SDES信息。 该函数需要一个指向RTCP数据包头的指针。

```c
   void rtp_read_sdes(rtcp_t *r)
   {
       int count = r->common.count;
       rtcp_sdes_t *sd = &r->r.sdes;
       rtcp_sdes_item_t *rsp, *rspn;
       rtcp_sdes_item_t *end = (rtcp_sdes_item_t *)
                               ((u_int32 *)r + r->common.length + 1);
       source *s;

       while (--count >= 0) {
           rsp = &sd->item[0];
           if (rsp >= end) break;
           s = find_member(sd->src);

           for (; rsp->type; rsp = rspn ) {
               rspn = (rtcp_sdes_item_t *)((char*)rsp+rsp->length+2);
               if (rspn >= end) {
                   rsp = rspn;
                   break;
               }
               member_sdes(s, rsp->type, rsp->data, rsp->length);
           }
           sd = (rtcp_sdes_t *)
                ((u_int32 *)sd + (((char *)rsp - (char *)sd) >> 2)+1);
       }
       if (count >= 0) {
           /* invalid packet format */
       }
   }
```

## A.6 生成一个随机的32位标识符

以下子例程使用RFC 1321[32]中发布的MD5例程生成随机的32位标识符。 系统例程可能未在所有操作系统上都存在，但它们应作为有关可以使用哪种信息的提示。 其他可能合适的系统调用包括：

- getdomainname(),
- getwd(), or
- getrusage()

“实时”视频或音频样本也是一个很好的随机数源，但是必须注意避免使用关闭的麦克风或盲目摄像头作为源[17]。

建议使用此例程或类似例程为产生RTCP周期的随机数生成器生成初始种子（如附录A.7所示），为序列号和时间戳生成初始值，并生成SSRC值 。 由于此例程可能会占用大量CPU，因此不宜将其直接用于生成RTCP周期，因为可预测性不是问题。 请注意，除非为type参数提供不同的值，否则该例程在重复调用上会产生相同的结果，直到系统时钟的值更改为止。

```c
   /*
    * Generate a random 32-bit quantity.
    */
   #include <sys/types.h>   /* u_long */
   #include <sys/time.h>    /* gettimeofday() */
   #include <unistd.h>      /* get..() */
   #include <stdio.h>       /* printf() */
   #include <time.h>        /* clock() */
   #include <sys/utsname.h> /* uname() */
   #include "global.h"      /* from RFC 1321 */
   #include "md5.h"         /* from RFC 1321 */

   #define MD_CTX MD5_CTX
   #define MDInit MD5Init
   #define MDUpdate MD5Update
   #define MDFinal MD5Final

   static u_long md_32(char *string, int length)
   {
       MD_CTX context;
       union {
           char   c[16];
           u_long x[4];
       } digest;
       u_long r;
       int i;

       MDInit (&context);
       MDUpdate (&context, string, length);
       MDFinal ((unsigned char *)&digest, &context);
       r = 0;
       for (i = 0; i < 3; i++) {
           r ^= digest.x[i];
       }
       return r;
   }                               /* md_32 */

   /*
    * Return random unsigned 32-bit quantity.  Use 'type' argument if
    * you need to generate several different values in close succession.
    */
   u_int32 random32(int type)
   {
       struct {
           int     type;
           struct  timeval tv;
           clock_t cpu;
           pid_t   pid;
           u_long  hid;
           uid_t   uid;
           gid_t   gid;
           struct  utsname name;
       } s;

       gettimeofday(&s.tv, 0);
       uname(&s.name);
       s.type = type;
       s.cpu  = clock();
       s.pid  = getpid();
       s.hid  = gethostid();
       s.uid  = getuid();
       s.gid  = getgid();
       /* also: system uptime */

       return md_32((char *)&s, sizeof(s));
   }    
```

## A.7计算RTCP传输间隔

以下功能实现了第6.2节中描述的RTCP发送和接收规则。 这些规则通过以下几个函数进行编码：

- rtcp_interval()计算确定的计算间隔，以秒为单位。 参数在6.3节中定义。
- 当RTCP传输计时器到期时，将调用OnExpire()
- 每当接收到RTCP数据包时，就会调用OnReceive()

OnExpire()和OnReceive()都将事件e作为参数。这是该参与者的下一个预定事件，可以是RTCP报告或BYE数据包。假定一下功能可用：

- Schedule(time t，event e) 调度事件e在时间t发生。当时间t到来时，将使用e作为参数调用函数OnExpire。
- Rechedule(time t，event e) 将先前安排的事件e重新安排为时间t。
- SendRTCPReport(event e) 发送RTCP报告
- SendBYEPacket(event e) 发送BYE数据包
- TypeOfEvent(event e) 如果正在处理的事件是要发送的BYE数据包，则返回EVENT_BYE，否则返回EVENT_REPORT。
- PacketType(p) 如果数据包p是RTCP report（非BYE），则返回PACKET_RTCP_REPORT；如果数据包p是BYE RTCP数据包，则返回PACKET_BYE，如果其是常规RTP数据包，则返回PACKET_RTP。
- ReceivedPacketSize() 和SentPacketSize() 返回参考数据包的大小（以八位字节为单位）。
- NewMember(p) 如果发送数据包p的参与者当前不在成员列表中，则返回1，否则返回0。 注意，此功能不足以实现完整的实现，因为应处理RTP数据包中的每个CSRC标识符和BYE数据包中的每个SSRC。
- NewSender(p) 如果发送数据包p的参与者当前不在成员列表的发送者子列表中，则返回1，否则返回0。
- AddMember() 和 RemoveMember() 可以从成员列表中添加和删除参与者。
- AddSender()和RemoveSender() 在成员列表的发件人自列表中添加和删除参与者。

这些功能必须进行扩展，以实现将发件人和非发件人的RTCP带宽部分指定为显式参数，而不是25％和75％的固定值。 如果参数之一为零，则rtcp_interval()的扩展实现将需要避免被零除。

```c
   double rtcp_interval(int members,
                        int senders,
                        double rtcp_bw,
                        int we_sent,
                        double avg_rtcp_size,
                        int initial)
   {
       /*
        * Minimum average time between RTCP packets from this site (in
        * seconds).  This time prevents the reports from `clumping' when
        * sessions are small and the law of large numbers isn't helping
        * to smooth out the traffic.  It also keeps the report interval
        * from becoming ridiculously small during transient outages like
        * a network partition.
        */
       double const RTCP_MIN_TIME = 5.;
       /*
        * Fraction of the RTCP bandwidth to be shared among active
        * senders.  (This fraction was chosen so that in a typical
        * session with one or two active senders, the computed report
        * time would be roughly equal to the minimum report time so that
        * we don't unnecessarily slow down receiver reports.)  The
        * receiver fraction must be 1 - the sender fraction.
        */
       double const RTCP_SENDER_BW_FRACTION = 0.25;
       double const RTCP_RCVR_BW_FRACTION = (1-RTCP_SENDER_BW_FRACTION);
       /*
       /* To compensate for "timer reconsideration" converging to a
        * value below the intended average.
        */
       double const COMPENSATION = 2.71828 - 1.5;

       double t;                   /* interval */
       double rtcp_min_time = RTCP_MIN_TIME;
       int n;                      /* no. of members for computation */

       /*
        * Very first call at application start-up uses half the min
        * delay for quicker notification while still allowing some time
        * before reporting for randomization and to learn about other
        * sources so the report interval will converge to the correct
        * interval more quickly.
        */
       if (initial) {
           rtcp_min_time /= 2;
       }
       /*
        * Dedicate a fraction of the RTCP bandwidth to senders unless
        * the number of senders is large enough that their share is
        * more than that fraction.
        */
       n = members;
       if (senders <= members * RTCP_SENDER_BW_FRACTION) {
           if (we_sent) {
               rtcp_bw *= RTCP_SENDER_BW_FRACTION;
               n = senders;
           } else {
               rtcp_bw *= RTCP_RCVR_BW_FRACTION;
               n -= senders;
           }
       }
       /*
        * The effective number of sites times the average packet size is
        * the total number of octets sent when each site sends a report.
        * Dividing this by the effective bandwidth gives the time
        * interval over which those packets must be sent in order to
        * meet the bandwidth target, with a minimum enforced.  In that
        * time interval we send one report so this time is also our
        * average time between reports.
        */
       t = avg_rtcp_size * n / rtcp_bw;
       if (t < rtcp_min_time) t = rtcp_min_time;

       /*
        * To avoid traffic bursts from unintended synchronization with
        * other sites, we then pick our actual next report interval as a
        * random number uniformly distributed between 0.5*t and 1.5*t.
        */
       t = t * (drand48() + 0.5);
       t = t / COMPENSATION;
       return t;
   }
   void OnExpire(event e,
                 int    members,
                 int    senders,
                 double rtcp_bw,
                 int    we_sent,
                 double *avg_rtcp_size,
                 int    *initial,
                 time_tp   tc,
                 time_tp   *tp,
                 int    *pmembers)
   {
       /* This function is responsible for deciding whether to send an
        * RTCP report or BYE packet now, or to reschedule transmission.
        * It is also responsible for updating the pmembers, initial, tp,
        * and avg_rtcp_size state variables.  This function should be
        * called upon expiration of the event timer used by Schedule().
        */

       double t;     /* Interval */
       double tn;    /* Next transmit time */

       /* In the case of a BYE, we use "timer reconsideration" to
        * reschedule the transmission of the BYE if necessary */

       if (TypeOfEvent(e) == EVENT_BYE) {
           t = rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn = *tp + t;
           if (tn <= tc) {
               SendBYEPacket(e);
               exit(1);
           } else {
               Schedule(tn, e);
           }

       } else if (TypeOfEvent(e) == EVENT_REPORT) {
           t = rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn = *tp + t;
           if (tn <= tc) {
               SendRTCPReport(e);
               *avg_rtcp_size = (1./16.)*SentPacketSize(e) +
                   (15./16.)*(*avg_rtcp_size);
               *tp = tc;

               /* We must redraw the interval.  Don't reuse the
                  one computed above, since its not actually
                  distributed the same, as we are conditioned
                  on it being small enough to cause a packet to
                  be sent */

               t = rtcp_interval(members,
                                 senders,
                                 rtcp_bw,
                                 we_sent,
                                 *avg_rtcp_size,
                                 *initial);

               Schedule(t+tc,e);
               *initial = 0;
           } else {
               Schedule(tn, e);
           }
           *pmembers = members;
       }
   }

   void OnReceive(packet p,
                  event e,
                  int *members,
                  int *pmembers,
                  int *senders,
                  double *avg_rtcp_size,
                  double *tp,
                  double tc,
                  double tn)
   {
       /* What we do depends on whether we have left the group, and are
        * waiting to send a BYE (TypeOfEvent(e) == EVENT_BYE) or an RTCP
        * report.  p represents the packet that was just received.  */

       if (PacketType(p) == PACKET_RTCP_REPORT) {
           if (NewMember(p) && (TypeOfEvent(e) == EVENT_REPORT)) {
               AddMember(p);
               *members += 1;
           }
           *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);
       } else if (PacketType(p) == PACKET_RTP) {
           if (NewMember(p) && (TypeOfEvent(e) == EVENT_REPORT)) {
               AddMember(p);
               *members += 1;
           }
           if (NewSender(p) && (TypeOfEvent(e) == EVENT_REPORT)) {
               AddSender(p);
               *senders += 1;
           }
       } else if (PacketType(p) == PACKET_BYE) {
           *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);

           if (TypeOfEvent(e) == EVENT_REPORT) {
               if (NewSender(p) == FALSE) {
                   RemoveSender(p);
                   *senders -= 1;
               }

               if (NewMember(p) == FALSE) {
                   RemoveMember(p);
                   *members -= 1;
               }

               if (*members < *pmembers) {
                   tn = tc +
                       (((double) *members)/(*pmembers))*(tn - tc);
                   *tp = tc -
                       (((double) *members)/(*pmembers))*(tc - *tp);

                   /* Reschedule the next report for time tn */

                   Reschedule(tn, e);
                   *pmembers = *members;
               }

           } else if (TypeOfEvent(e) == EVENT_BYE) {
               *members += 1;
           }
       }
   }

```

## A.8估计到达间隔抖动

下面的代码片段实现了6.4.1节中给出的算法，用于计算将插入接收报告的到达间隔抖动字段中的RTP数据到达时间的统计方差的估计值。 输入为r-> ts，即传入数据包的时间戳，到达时为当前时间（单位相同）。 这里指向源的状态； s-> transit保留前一个数据包的相对传输时间，s-> jitter保留估计的抖动。 接收报告的抖动字段以时间戳为单位进行度量，并表示为无符号整数，但抖动估计值保留在浮点中。 随着每个数据包的到达，抖动估计值将更新：

```c
      int transit = arrival - r->ts;
      int d = transit - s->transit;
      s->transit = transit;
      if (d < 0) d = -d;
      s->jitter += (1./16.) * ((double)d - s->jitter);
```

当为此成员生成一个接收报告块（rr指向该块）时，将返回当前的抖动估计：

```c
rr->jitter = (u_int32) s->jitter;
```

可替代地，抖动估计可以保持为整数，但是可以缩放以减小舍入误差。 除最后一行外，计算结果相同：

```c
s->jitter += d - ((s->jitter + 8) >> 4);
```

在这种情况下，将对接收报告的估计值进行采样，如下所示：

```c
rr->jitter = s->jitter >> 4;
```

