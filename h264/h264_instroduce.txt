# H264结构

## 基本概念

### 1、预测编码  

   压缩算法的本质就是去除信号间的冗余，什么是信号的冗余呢？信号之间的相关性就是冗余，人类听觉或视觉系统感觉不到的或者掩蔽的也可以当做冗余成分。今天谈谈预测编码的概念，这是一种非常直观和简单易行的方法。说它直观，以图像为例，前后两帧或者同一图像的相邻像素都存在着相似性、相关性，我们完全可以通过当前帧和一组预测系数，推测出下一帧图像，当然也可以从当前像素推测出周围像素的变化。通过实际值与预测值的差，去除了一部分冗余，使得信号的动态范围变小了，表示这些信号的比特数减少了，从而达到压缩的目的。

   对于视频信号的预测编码分成两种，一个是帧间预测编码，一个是帧内预测编码。帧内预测是从空间上去除同一帧图像内宏块之间的冗余。H264中，有4x4亮度预测模式、16x16亮度预测模式、8x8色度块预测模式以及一种I_PCM编码模式，如何选择最优的编码模型是一个不太容易的问题。

   帧间预测编码效率比帧内编码要高，它是从时间上去除图像帧与帧之间的冗余，分为单向预测、双向预测。一般双向预测会增加编码延时，所以在实时通信中用的不多。在帧间预测中，就不得不提运动估计这个概念，在活动图像邻近帧中的景物会发生空间上的位移，得到这个运动偏移的过程就是运动估计，涉及到各种搜索算法，同时这一部分的复杂度也是H264的重点。

### 2、变换编码

   变换编码是指将空间域的图像变换到频域，这样会产生相关性很小的一些变换系数，并对其进行压缩编码。通常采用DCT变换，因为它的性能接近K-L变换，同时具有快速算法，非常适合图像变换编码。变换编码比预测编码要复杂，但是各种误差（量化、信道误差）不会向后面扩展，对视觉影响不大。

### 3、熵编码

   利用信源的统计特性进行码率压缩的编码称为熵编码。特点是无损编码，但是压缩率比较低，一般用在变换编码后面作进一步压缩。常用的有变长编码（huffman编码）和算术编码。

1） 变长编码

   对出现概率大的符号分配短字长的二进制码，对出现概率小的符号分配长字长的二进制码，得到符号平均码长最短的码。也称为最佳编码。

2） 算术编码

   与huffman编码不同，不采用码字表示输入符号的方法，而是采用一个浮点数来代替一串输入符号，经算术编码后输出一个小于1，大于等于0的浮点数，在解码端在进行唯一的解码，恢复原符号序列。

   这两种编码方法实际应用中都有受硬件精度的问题，即如何定点化表示小数的问题。

## H264码流分层

![nalu_layout](nalu_layout.png)

此处展示的第一层分别为在h264 NALU上Annexb格式和RTP格式的打包

## 相关名词解释

### VCL & NAL & RBSP

H264 原始码流是由一个接一个 NALU（NAL Unit） 组成，它的功能分为两层，VCL（Video Coding Layer）视频编码层和 NAL（Network Abstraction Layer）网络提取层。

**SODB:**　数据比特串－－＞最原始的编码数据

**RBSP :**（Raw Byte Sequence Payload）原始字节序列载荷－－＞在SODB的后面填加了结尾比特（RBSP trailing bits　一个bit“1”）若干比特“0”,以便字节对齐。它有可能是图像信息数据，也有可能是图像数据，也有可能为空。

![rbsp](rbsp.png)

其中的红色部分为**stop bit**，标示RBSP中数据部分的结束，值为1。

SODB是最原始的编码数据，长度不一定是8的倍数，此时需要对齐。即在SODB的后面填加了若干bit（值为0），以便字节对齐。可见图上的灰白色部分为**TRAIL**。

**EBSP:**　扩展字节序列载荷– >在RBSP基础上填加了仿校验字节（0X03）它的原因是：　在NALU加到Annexb上时，需要填加每组NALU之前的开始码 StartCodePrefix,如果该NALU对应的slice为一帧的开始则用4位字节表示，0x00000001,否则用3位字节表示 0x000001.
为了使NALU主体中不包括与开始码相冲突的，在编码时，每遇到两个字节连续为0，就插入一个字节的0x03。解码时将0x03去掉。 也称为脱壳操作。

**H.264的功能分为两层，视频编码层（VCL）和网络提取层（NAL）**

**VCL：**包括核心压缩引擎和块、宏块和片的语法级别定义，设计目标是尽可能地独立于网络进行高效的编码；
**NAL：**负责将 VCL 产生的比特字符串适配到各种各样的网络和多元环境中，覆盖了所有片级以上的语法级别；

NAL是 H.264 为适应网络传输应用而制定的一层数据打包操作。传统的视频编码算法编完的视频码流在任何应用领域下（无论用于存储、传输等）都是统一的码流模式，视频码流仅有视频编码层 VCL（Video Coding Layer）。而 H.264 可根据不同应用增加不同的 NAL 片头，以适应不同的网络应用环境，减少码流的传输差错。

在 VCL 进行数据传输或存储之前，这些编码的 VCL 数据，被映射或封装进NAL单元（NALU）。


一个 NALU = 一组对应于视频编码的 NALU 头部信息 + 一个原始字节序列负荷（RBSP，Raw Byte Sequence Payload）

![nalu_set](nalu_set.png)

一个原始的 H.264 NALU 单元常由 [StartCode] [NALU Header] [NALU Payload] 三部分组成，其中 Start Code 用于标示这是一个NALU 单元的开始，必须是 “00 00 00 01”

对于Annex B 格式的H264，

一个NALU中的数据并未包含他的大小（长度）信息，因此我们并不能简单的将一个个NALU连接起来生成一个流，因为数据流的接收端并不知道一个NALU从哪里结束，另一个NALU从哪里开始。
 Annex B格式用起始码（Start Code）来解决这个问题，它在每个NALU的开始处添加三字节或四字节的起始码0x000001或0x00000001。通过定位起始码，解码器就可以很容易的识别NALU的边界。
 当然，用起始码定位NALU边界存在一个问题，即NALU中可能存在与起始码相同的数据。为了防止这个问题，在构建NALU时，需要将数据中的0x000000,0x000001,0x000002,0x000003中插入防竞争字节（Emulation Prevention Bytes)0x03，使其变为：

 0x000000 = 0x0000 03 00
 0x000001 = 0x0000 03 01
 0x000002 = 0x0000 03 02
 0x000003 = 0x0000 03 03
 解码器在检测到0x000003时，将0x03抛弃，恢复原始数据。

由于Annex B格式每个NALU都包含起始码，所以解码器可以从视频流随机点开始进行解码，常用于实时的流格式。在这种格式中通常会周期性的重复SPS和PPS，并且经常是在每一个关键帧之前。

## 片（slice）

![nalu_slice](nalu_slice.png)

一个片 = Slice Header + Slice Data

片是 H.264 提出的新概念，实际原始视频图像数据保存在 VCL 层级的 NAL Unit 中，这部分数据在码流中被称作是片（slice）。一个 slice 包含一帧图像的部分或全部数据，换言之，一帧视频图像可以编码为一个或若干个 slice。一个 slice 最少包含一个宏块，最多包含整帧图像的数据。在不同的编码实现中，同一帧图像中所构成的 slice 数目不一定相同。

一个 slice 编码之后被打包进一个 NALU，所以 slice = NALU

***那么为什么要设置片呢?***
设置片的目的是为了限制误码的扩散和传输，应使编码片相互间是独立的。某片的预测不能以其他片中的宏块为参考图像，这样某一片中的预测误差才不会传播到其他片中。

在上图中，可以看到每个图像中，若干宏块（Macroblock）被排列成片。一个视频图像可编成一个或更多个片，每片包含整数个宏块 (MB)，每片至少包含一个宏块。

slice 类型
slice	意义
I slice	只包含 I 宏块
P slice	包含 P 和 I 宏块
B slice	包含 B 和 I 宏块
SP slice	包含 P 或 I 宏块,用于不同码流之间的切换
SI slice	一种特殊类型的编码宏块
slice 组成
每一个 slice 总体来看都由两部分组成，一部分作为 slice header，用于保存 slice 的总体信息（如当前 slice 的类型等），另一部分为 slice body，通常是一组连续的宏块结构（或者宏块跳过信息）

### Slice_Header

`1、first_mb_in_slice：片中的第一个宏块的地址, 片通过这个句法元素来标定它自己的地址。`
					`注意：在【帧场自适应模式】下，宏块都是成对出现，这时本句法元素表示的是第几个宏块对，`
							`对应的第一个宏块的真实地址应该是2 * first_mb_in_slice`

`2、slice_type：指明片的类型，IDR 图像时, slice_type 等于 2, 4, 7, 9。`
`num_of_slice_type	slice_type`
	 `0				P(P slice)`
	 `1				B(B slice)`
	 `2				I(I slice)`
	 `3				SP(SP slice)`
	 `4				SI(SI slice)`
	 `5				P(P slice)`
	 `6				B(B slice)`
	 `7				I(I slice)`
	 `8				SP(SP slice)`
	 `9				SI(SI slice)`

`3、pic_parameter_set_id：当前slice所依赖的pps的id；`

`4、colour_plane_id：表示当前的颜色分量，0、1、2分别表示Y、U、V分量。`
`//依赖separate_colour_plane_flag=1而存在`

`5、frame_num: 每个参考帧都有一个依次连续的 frame_num 作为它们的标识,这指明了各图像的解码顺序。但事实上我们在表中可以看到， frame_num 的出现没有 if 语句限定条件，这表明非参考帧的片头也会出现 frame_num。只是当该个图像是参考帧时，它所携带的这个句法元素在解码时才有意义。如表：`
	`图像序号	图像类型		是否作为参考	frame_num`
	`1		I			是			0`
	`2		P			是			1`
	`3		B			否			2`
	`4		P			是			2`
	`5		B			否			3`
	`6		P			是			3`
	`7		B			否			4`
	`8		P			是			4`

`6、field_pic_flag：场编码标识位。`
					`=1：表示当前slice按照场进行编码`
					`=0：表示当前slice按照帧进行编码`

`7、bottom_field_flag：底场标识位。`
					`=1：当前slice是底场`
					`=0：当前slice是顶场`

`8、idr_pic_id：IDR帧的序号。某一个IDR帧所属的所有slice的idr_pic_id应保持一致。`
	`//依赖于IdrPicFlag而存在👉一般的I帧是不会有这个语法的`
	`在场模式下， IDR 帧的两个场有相同的 idr_pic_id 值。` 
	`idr_pic_id 的取值范围是 [0， 65535]，和 frame_num 类似，当它的值超出这个范围时，它会以循环的方式重新开始计数。`

`9、pic_order_cnt_lsb：表示当前帧序号的另一种计量方式。`

`10、delta_pic_order_cnt_bottom：表示顶场与底场POC差值的计算方法，不存在则默认为0；`
`11、slice_qp_delta：指出在用于当前片的所有宏块的量化参数的初始值。`
`12、SliceQPY = 26 + pic_init_qp_minus26 + slice_qp_delta`
`QPY 的范围是 0 to 51。`
`我们前文已经提到， H.264 中量化参数是分图像参数集、片头、宏块头三层给出的，前两层各自给出一个偏移值，这个句法元素就是片层的偏移。`

### 拆分

若完整的视频帧未被切分成多个slice时，可直接被解码成YUV或RGB数据，但是当切分成多个slice，需要根据first_mb_in_slice计算每个帧片所在位置。

比如B帧中数据为0x00 0x00 0x00 0x01 0x41 0xE2，读取第6位转成二进制：1110 0010，与上0x80：0xB8&0x80=0x80,即表示为一帧的第一片(可查询指数哥伦布码，即第一个位为1)。接下来一包数据为0x00 0x00 0x00 0x01 0x41 0x63，则与上0x80为0x0，则表示不是第一片(不是第一个片时的值在上一包的基础上会出现递增)。可归纳规律（假设的数据）：

    第一包：0x00 0x00 0x00 0x01 0x41 0xE1
    
    第二包：0x00 0x00 0x00 0x01 0x41 0x62
    
    第三包：0x00 0x00 0x00 0x01 0x41 0x63
    
    第四包：0x00 0x00 0x00 0x01 0x41 0xE2

可看出第一包0xE1&0x80=0x80则是第一片，0x62&0x80=0x0则为第二包，直到遇到下一个0x80时为完整的一帧(第一包+第二包+第三包)。
一般情况下I帧不会被切分成多个slice，而是以完整帧进行传输，P帧多数情况下存在切分的情况。

## 宏块(Macroblock)：

- 编码视频信息的基本单元；
- 在编码过程中提供了较强的灵活性；

一帧图像划分为多个宏块，每个宏块包含：

- 1个16×16像素的亮度像素块
- 两个8×8像素的色度像素块；

常用宏块类型：

- I宏块：采用帧内预测宏块，可能位于I/B/P帧；利用从当前片中已解码的像素作为参考进行帧内预测
- P宏块：采用单向帧间预测，只存在于P帧；利用前面已编码图像作为参考进行帧内预测
- B宏块：采用双向帧间预测，只存在于B帧；利用双向的参考图像（当前和未来的已编码图像帧）进行帧内预测

                            各种片中允许出现的宏块类型

片类型	允许出现的宏块种类
I (slice)	I 宏块
P (slice)	P 宏块、 I 宏块
B (slice)	B 宏块、 I 宏块
SI (slice)	SI 宏块、 I 宏块
SP (slice)	P 宏块、 I 宏块

## **NALU Header**

nal_unit_type 是否包含 VCL 层编码数据分为 VCL NAL units 和 non-VCL NAL units；

VCL NAL units 中包含 VCL 层编码输出的数据, 而 non-VCL NAL units 则不包含。

![nal_header_type](/Users/chifengliang/Desktop/H264%E7%BB%93%E6%9E%84/nal_header_type.png)

例如,下面幅图分别代表IDR与非IDR帧具体的码流信息:

 ![h264_sps](/Users/chifengliang/Desktop/H264%E7%BB%93%E6%9E%84/h264_sps.png)

在一个NALU中，第一个字节（即NALU header）用以表示其包含数据的类型及其他信息。我们假定一个头信息字节为0x67作为例子：

| 十六进制 | 二进制     |
| -------- | ---------- |
| 0x67     | 0 11 00111 |

如表所示，头字节可以被解析成3个部分，其中：

1>. forbidden_zero_bit = 0：占1个bit，禁止位，用以检查传输过程中是否发生错误，0表示正常，1表示违反语法；

2>. nal_ref_idc = 3：占2个bit，用来表示当前NAL单元的优先级。非0值表示参考字段/帧/图片数据，其他不那么重要的数据则为0。对于非0值，值越大表示NALU重要性越高

3>. nal_unit_type = 7：最后5位用以指定NALU类型，NALU类型定义如上表

从表中我们可以获知,NALU类型1-5为视频帧，其余则为非视频帧。在解码过程中，我们只需要取出NALU头字节的后5位，即将NALU头字节和0x1F进行与计算即可得知NALU类型，即：

```c
NALU类型 = NALU头字节 & 0x1F
```

注意: 可以将start code理解为不同nalu的分隔符,header是某种类型的key,payload是该key的value.



## 帧（frame）和场（filed）

视频的一场和一帧用来产生一个编码图像，一帧通常是一个完整的图像，当采集视频信号时，如果采用隔行扫描（奇、偶数行），则扫描下来的一帧图像就被分成了两个部分，这每一部分都被称为 [场]，根据次序，分为 [顶场] 和 [底场]。

**扩展阅读：为什么会产生场的概念？**
人眼可察觉到的电视视频图像刷新中的闪烁为 0.02 秒，即当电视系统的帧率低于 50 帧/秒，人眼可感觉得出画面的闪烁。常规如 PAL 制式电视系统帧率为 25 帧/秒、NTSC 制式的则为 30 帧/秒，如果采用逐行扫描将不可避免地在视频刷新时产生闪烁现象。而另一方面如果单纯的提高帧率达到避免闪烁刷新效果，则会增加系统的频带宽度。

这便引出了隔行扫描技术及 [场] 的概念

在隔行扫描中，每一帧包含两个场（top field）和（bottom field），其中每个 field 包含一帧中一半数量的水平线，top field 包含所有奇数线，bottom field 则包含所有偶数线。则在电视显示过程中，电子枪每发射一行隔一行—先发射奇数行13579…（top field）回头再发射2468…（bottom field）利用两次扫描来完成一幅图像，因为视觉的滞留性，我们看到的效果是差不多的。如在 NTSC 视频中 frame 的频率为30次/秒-àfield的频率则为 60 次/秒，大于了人眼可察觉闪烁的频率。

**适用类型**

| 方式       | 作用域                         |
| ---------- | ------------------------------ |
| 帧编码方式 | 活动量较小或者静止的图像宜采用 |
| 场编码方式 | 活动量较大的运动图像           |

![frame_filed](frame_filed.png)

![frame_filed2](frame_filed2.png)

**I 帧、P 帧、B 帧与 pts/dts**

| 帧的分类 |                             中文                             |                             意义                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   I帧    |                帧内编码帧，又称 intra picture                | I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。I帧可以看成是一个图像经过压缩后的产物 |
|   P帧    |            前向预测编码帧，又称 predictive-frame             | 通过充分将低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧 |
|   B帧    | 双向预测帧，又称 bi-directional interpolated prediction frame | 既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像,也叫双向预测帧 |

- I frame: 自身可以通过视频解压算法解压成一张单独的完整的图片；
- P frame：需要参考其前面的一个 I frame 或者 B frame 来生成一张完整的图片；
- B frame: 则要参考其前一个 I 或者 P帧 及其后面的一个 P 帧来生成一张完整的图片；

**pts/dts**

| 名称                           | 意义                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| PTS（Presentation Time Stamp） | PTS 主要用于度量解码后的视频帧什么时候被显示出来             |
| DTS（Decode Time Stamp）       | DTS 主要是标识内存中的 bit 流什么时候开始送入解码器中进行解码;<br />用于视频的同步和输出.在渲染的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的。 |

DTS 与 PTS 的不同：
DTS 主要用户视频的解码，在解码阶段使用。PTS主要用于视频的同步和输出，在 display 的时候使用。再没有 B frame 的时候输出顺序是一样的。



## GOP

GOP 是画面组，一个 GOP 是一组连续的画面。
GOP 一般有两个数字，如 M = 3，N = 12，M 制定 I 帧与 P 帧之间的距离，N 指定两个 I 帧之间的距离。那么现在的 GOP 结构是

```c
I BBP BBP BBP BB I
```

GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。

![h264_gop](h264_gop.png)

所以在码率不变的前提下，GOP值越大，P、B帧的数量会越多，画面细节更多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。

　　需要说明的是，通过提高GOP值来提高图像质量是有限度的，在遇到场景切换的情况时，H.264编码器会自动强制插入一个I帧，此时实际的GOP值被缩短了。另一方面，在一个GOP中，P、B帧是由I帧预测得到的，当I帧的图像质量比较差时，会影响到一个GOP中后续P、B帧的图像质量，直到下一个GOP开始才有可能得以恢复，所以GOP值也不宜设置过大。

　　同时，由于P、B帧的复杂度大于I帧，所以过多的P、B帧会影响编码效率，使编码效率降低。另外，过长的GOP还会影响Seek操作（找I帧）的响应速度，由于P、B帧是由前面的I或P帧预测得到的，所以Seek操作需要直接定位，解码某一个P或B帧时，需要先解码得到本GOP内的I帧及之前的N个预测帧才可以，GOP值越长，需要解码的预测帧就越多，seek响应的时间也越长。

## IDR

一个序列的第一帧叫做 IDR帧（Instantaneous Decoding Refresh，立即解码刷新）。IDR 图像都是 I 帧图像。引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。

I 帧和 IDR 帧都是使用帧内预测，本质上是同一个东西，在解码和编码中为了方便，将视频序列中第一个 I 帧和其他 I 帧区分开，所以把第一个 I 帧称作 IDR，这样就方便控制编码和解码流程。

IDR 帧的作用是立刻刷新，使错误不致传播，从 IDR 帧开始，重新算一个新的序列开始编码。

**核心作用**

H.264 引入 IDR 帧是为了解码的重同步，当解码器解码到 IDR 帧时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会，IDR 帧之后的帧永远不会使用 IDR 之前的图像的数据来解码。


## RTP打包

RTP 头的结构:

```c
    0          1          2          3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X| CC  |M|   PT   |    sequence number     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              timestamp              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      synchronization source (SSRC) identifier      |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |      contributing source (CSRC) identifiers       |
   |               ....               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

   负载类型 Payload type(PT): 7bits
rfc里面对一些早期的格式定义了这个payload type。但是后来的，如h264并没有分配，那就用96来代替。因此现在96以上都不表示特定的格式，具体表示什么要用sdp或者其他协议来协商。

   序列号 Sequence number(SN): 16bits
   时间戳 Timestamp: 32bits

**rtp playload部分**

Rtp负载第一个字节的结构如下,它和H.264的NALU头结构一致，可以把它认为是RTP h264负载类型字节，完全是多增加的一个字节，不影响后面的NALU结构

```c
   +---------------+
   |0|1|2|3|4|5|6|7|
   +-+-+-+-+-+-+-+-+
   |F| NRI | Type  |
   +---------------+
```

这里的Type类型除1-23外还可取以下值：

 24  STAP-A  单一时间的组合包
 25   STAP-B  单一时间的组合包
 26  MTAP16  多个时间的组合包
 27  MTAP24  多个时间的组合包
 28  FU-A   分片的单元
 29  FU-B   分片的单元

如果使用1-23就是：单一NAL单元模式

**封包介绍：**

单一NAL单元模式

 对于 NALU 的长度小于 MTU 大小的包, 一般采用单一 NAL 单元模式.
 对于一个原始的 H.264 NALU 单元常由 [Start Code] [NALU Header] [NALU Payload] 三部分组成, 其中 Start Code 用于标示这是一个

NALU 单元的开始, 必须是 "00 00 00 01" 或 "00 00 01", NALU 头仅一个字节, 其后都是 NALU 单元内容.
 打包时去除 "00 00 01" 或 "00 00 00 01" 的开始码, 把其他数据封包的 RTP 包即可.

```c
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |F|NRI|  type   |                                               |
  +-+-+-+-+-+-+-+-+                                               |
  |                                                               |
  |               Bytes 2..n of a Single NAL unit                 |
  |                                                               |
  |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               :...OPTIONAL RTP padding        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

例：
 如有一个 H.264 的 NALU 是这样的:

 [00 00 00 01 67 42 A0 1E 23 56 0E 2F ... ]

 这是一个序列参数集 NAL 单元. [00 00 00 01] 是四个字节的开始码, 67 是 NALU 头, 42 开始的数据是 NALU 内容.

 封装成 RTP 包将如下:

 [ RTP Header ] [ 67 42 A0 1E 23 56 0E 2F ]

 即只要去掉 4 个字节的开始码就可以了.

组合封包模式

 其次, 当 NALU 的长度特别小时, 可以把几个 NALU 单元封在一个 RTP 包中.

```c++
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | FU indicator   |    FU header  |                                |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  |                         FU payload                            |
  |                                                               |
  |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               :...OPTIONAL RTP padding        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  Figure 14.  RTP payload format for FU-A
```

这里只介绍STAP-A模式，如果是STAP-B的话会多加入一个DON域，另外还有MTAP16、MTAP24。

**FU indicator有以下格式：**

```
  +---------------+
  |0|1|2|3|4|5|6|7|
  +-+-+-+-+-+-+-+-+
  |F|NRI|  Type   |
  +---------------+
```

FU指示字节的类型域的28，29表示FU-A和FU-B。NRI域的值必须根据分片NAL单元的NRI域的值设置。（此处Type就是rtp分片类型） 见下表

```
  .Type   Packet      Type name                       
  ---------------------------------------------------------
  0      undefined                                    -
  1-23   NAL unit    Single NAL unit packet per H.264  
  24     STAP-A     Single-time aggregation packet    
  25     STAP-B     Single-time aggregation packet    
  26     MTAP16    Multi-time aggregation packet     
  27     MTAP24    Multi-time aggregation packet     
  28     FU-A      Fragmentation unit                
  29     FU-B      Fragmentation unit                 
  30-31  undefined  
```

**FU header的格式如下：**

```
  +---------------+
  |0|1|2|3|4|5|6|7|
  +-+-+-+-+-+-+-+-+
  |S|E|R|  Type   |
  +---------------+
```

S: 1 bit 当设置成1,开始位指示分片NAL单元的开始。当跟随的FU荷载不是分片NAL单元荷载的开始，开始位设为0。

E: 1 bit 当设置成1, 结束位指示分片NAL单元的结束，即, 荷载的最后字节也是分片NAL单元的最后一个字节。
当跟随的FU荷载不是分片NAL单元的最后分片,结束位设置为0。

R: 1 bit, 保留位必须设置为0，接收者必须忽略该位。

Type: 5 bits, 此处的Type就是NALU头中的Type,取1-23的那个值，表示 NAL单元荷载类型定义.

**拆包和解包**

**拆包**：当编码器在编码时需要将原有一个NAL按照FU-A进行分片，原有的NAL的单元头与分片后的FU-A的单元头有如下关系：

**原始的NAL头的前三位为FU indicator的前三位，原始的NAL头的后五位为FU header的后五位，**

FU indicator与FU header的剩余位数根据实际情况决定。

**解包：**当接收端收到FU-A的分片数据，需要将所有的分片包组合还原成原始的NAl包时，FU-A的单元头与还原后的NAL的关系如下：

还原后的NAL头的八位是由FU indicator的前三位加FU header的后五位组成，即：

nal_unit_type = (fu_indicator & 0xe0) | (fu_header & 0x1f)

## 码流格式

​    H.264标准中指定了视频如何编码成独立的包，但如何存储和传输这些包却未作规范，虽然标准中包含了一个Annex附件，里面描述了一种可能的格式Annex B，但这并不是一个必须要求的格式。
为了针对不同的存储传输需求，出现了两种打包方法。一种即Annex B格式，另一种称为AVCC格式。

### Annex B

从上文可知，一个NALU中的数据并未包含他的大小（长度）信息，因此我们并不能简单的将一个个NALU连接起来生成一个流，因为数据流的接收端并不知道一个NALU从哪里结束，另一个NALU从哪里开始。
 Annex B格式用起始码（Start Code）来解决这个问题，它在每个NALU的开始处添加三字节或四字节的起始码0x000001或0x00000001。通过定位起始码，解码器就可以很容易的识别NALU的边界。
 当然，用起始码定位NALU边界存在一个问题，即NALU中可能存在与起始码相同的数据。为了防止这个问题，在构建NALU时，需要将数据中的0x000000,0x000001,0x000002,0x000003中插入防竞争字节（Emulation Prevention Bytes)0x03，使其变为：

 0x000000 = 0x0000 03 00
 0x000001 = 0x0000 03 01
 0x000002 = 0x0000 03 02
 0x000003 = 0x0000 03 03
 解码器在检测到0x000003时，将0x03抛弃，恢复原始数据。

由于Annex B格式每个NALU都包含起始码，所以解码器可以从视频流随机点开始进行解码，常用于实时的流格式。在这种格式中通常会周期性的重复SPS和PPS，并且经常时在每一个关键帧之前。

### AVCC

AVCC格式不使用起始码作为NALU的分界，这种格式在每个NALU前都加上一个指定NALU长度的大端格式表示的前缀。这个前缀可以是1、2或4个字节，所以在解析AVCC格式的时候需要将指定的前缀字节数的值保存在一个头部对象中，这个都通常称为extradata或者sequence header。同时，SPS和PPS数据也需要保存在extradata中。
 H.264 extradata语法如下：

![h264_aac](h264_aac.png)

其中第5字节的后2位表示的就是NAL size的字节数。需要注意的是，这个NALULengthSizeMinusOne是NALU前缀长度减一，即，假设前缀长度为4，那么这个值应该为3。
 这里还需要注意的一点是，虽然AVCC格式不使用起始码，但防竞争字节还是有的。

AVCC格式的一个优点在于解码器配置参数在一开始就配置好了，系统可以很容易的识别NALU的边界，不需要额外的起始码，减少了资源的浪费，同时可以在播放时调到视频的中间位置。这种格式通常被用于可以被随机访问的多媒体数据，如存储在硬盘的文件。

## 重要参数

### 视频参数集VPS（Video Parameter Set）

VPS主要用于传输视频分级信息，有利于兼容标准在可分级视频编码或多视点视频的扩展。

（1）用于解释编码过的视频序列的整体结构，包括时域子层依赖关系等。HEVC中加入该结构的主要目的是兼容标准在系统的多子层方面的扩展，处理比如未来的可分级或者多视点视频使用原先的解码器进行解码但是其所需的信息可能会被解码器忽略的问题。

（2）对于给定视频序列的某一个子层，无论其SPS相不相同，都共享一个VPS。其主要包含的信息有：多个子层或操作点共享的语法元素；档次和级别等会话关键信息；其他不属于SPS的操作点特定信息。

（3）编码生成的码流中，第一个NAL单元携带的就是VPS信息

### 序列参数集SPS（Sequence Parameter Set）

包含一个CVS中所有编码图像的共享编码参数。

（1）一段HEVC码流可能包含一个或者多个编码视频序列，每个视频序列由一个随机接入点开始，即IDR/BLA/CRA。序列参数集SPS包含该视频序列中所有slice需要的信息。

（2）SPS的内容大致可以分为几个部分：1、自引ID；2、解码相关信息，如档次级别、分辨率、子层数等；3、某档次中的功能开关标识及该功能的参数；4、对结构和变换系数编码灵活性的限制信息；5、时域可分级信息；6、VUI。

### 图像参数集PPS（Picture Parameter Set）

包含一幅图像所用的公共参数，即一幅图像中所有片段SS（Slice Segment）引用同一个PPS。

（1）PPS包含每一帧可能不同的设置信息，其内容同H.264中的大致类似，主要包括：1、自引信息；2、初始图像控制信息，如初始QP等；3、分块信息。

（2）在解码开始的时候，所有的PPS全部是非活动状态，而且在解码的任意时刻，最多只能有一个PPS处于激活状态。当某部分码流引用了某个PPS的时候，这个PPS便被激活，称为活动PPS，一直到另一个PPS被激活。

参数集包含了相应的编码图像的信息。SPS包含的是针对一连续编码视频序列的参数（标识符seq_parameter_set_id、帧数及POC的约束、参考帧数目、解码图像尺寸和帧场编码模式选择标识等等）。PPS对应的是一个序列中某一幅图像或者某几幅图像 ，其参数如标识符pic_parameter_set_id、可选的seq_parameter_set_id、熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等等。

通常，SPS 和PPS 在片的头信息和数据解码前传送至解码器。每个片的头信息对应一个pic_parameter_set_id，PPS被其激活后一直有效到下一个PPS被激活；类似的，每个PPS对应一个seq_parameter_set_id，SPS被其激活以后将一直有效到下一个SPS被激活。 参数集机制将一些重要的、改变少的序列参数和图像参数与编码片分离，并在编码片之前传送
 至解码端，或者通过其他机制传输。

